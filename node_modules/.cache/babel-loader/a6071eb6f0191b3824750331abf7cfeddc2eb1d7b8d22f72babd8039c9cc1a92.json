{"ast":null,"code":"import { TicksClass } from \"../core/type/Ticks\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Sequence extends ToneEvent {\n  constructor() {\n    super(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n    this.name = \"Sequence\";\n    /**\n     * The object responsible for scheduling all of the events\n     */\n    this._part = new Part({\n      callback: this._seqCallback.bind(this),\n      context: this.context\n    });\n    /**\n     * private reference to all of the sequence proxies\n     */\n    this._events = [];\n    /**\n     * The proxied array\n     */\n    this._eventsArray = [];\n    const options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n    this._subdivision = this.toTicks(options.subdivision);\n    this.events = options.events;\n    // set all of the values\n    this.loop = options.loop;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this.playbackRate = options.playbackRate;\n    this.probability = options.probability;\n    this.humanize = options.humanize;\n    this.mute = options.mute;\n    this.playbackRate = options.playbackRate;\n  }\n  static getDefaults() {\n    return Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n      events: [],\n      loop: true,\n      loopEnd: 0,\n      loopStart: 0,\n      subdivision: \"8n\"\n    });\n  }\n  /**\n   * The internal callback for when an event is invoked\n   */\n  _seqCallback(time, value) {\n    if (value !== null) {\n      this.callback(time, value);\n    }\n  }\n  /**\n   * The sequence\n   */\n  get events() {\n    return this._events;\n  }\n  set events(s) {\n    this.clear();\n    this._eventsArray = s;\n    this._events = this._createSequence(this._eventsArray);\n    this._eventsUpdated();\n  }\n  /**\n   * Start the part at the given time.\n   * @param  time    When to start the part.\n   * @param  offset  The offset index to start at\n   */\n  start(time, offset) {\n    this._part.start(time, offset ? this._indexTime(offset) : offset);\n    return this;\n  }\n  /**\n   * Stop the part at the given time.\n   * @param  time  When to stop the part.\n   */\n  stop(time) {\n    this._part.stop(time);\n    return this;\n  }\n  /**\n   * The subdivision of the sequence. This can only be\n   * set in the constructor. The subdivision is the\n   * interval between successive steps.\n   */\n  get subdivision() {\n    return new TicksClass(this.context, this._subdivision).toSeconds();\n  }\n  /**\n   * Create a sequence proxy which can be monitored to create subsequences\n   */\n  _createSequence(array) {\n    return new Proxy(array, {\n      get: (target, property) => {\n        // property is index in this case\n        return target[property];\n      },\n      set: (target, property, value) => {\n        if (isString(property) && isFinite(parseInt(property, 10))) {\n          if (isArray(value)) {\n            target[property] = this._createSequence(value);\n          } else {\n            target[property] = value;\n          }\n        } else {\n          target[property] = value;\n        }\n        this._eventsUpdated();\n        // return true to accept the changes\n        return true;\n      }\n    });\n  }\n  /**\n   * When the sequence has changed, all of the events need to be recreated\n   */\n  _eventsUpdated() {\n    this._part.clear();\n    this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n    // update the loopEnd\n    this.loopEnd = this.loopEnd;\n  }\n  /**\n   * reschedule all of the events that need to be rescheduled\n   */\n  _rescheduleSequence(sequence, subdivision, startOffset) {\n    sequence.forEach((value, index) => {\n      const eventOffset = index * subdivision + startOffset;\n      if (isArray(value)) {\n        this._rescheduleSequence(value, subdivision / value.length, eventOffset);\n      } else {\n        const startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n        this._part.add(startTime, value);\n      }\n    });\n  }\n  /**\n   * Get the time of the index given the Sequence's subdivision\n   * @param  index\n   * @return The time of that index\n   */\n  _indexTime(index) {\n    return new TicksClass(this.context, index * this._subdivision + this.startOffset).toSeconds();\n  }\n  /**\n   * Clear all of the events\n   */\n  clear() {\n    this._part.clear();\n    return this;\n  }\n  dispose() {\n    super.dispose();\n    this._part.dispose();\n    return this;\n  }\n  //-------------------------------------\n  // PROXY CALLS\n  //-------------------------------------\n  get loop() {\n    return this._part.loop;\n  }\n  set loop(l) {\n    this._part.loop = l;\n  }\n  /**\n   * The index at which the sequence should start looping\n   */\n  get loopStart() {\n    return this._loopStart;\n  }\n  set loopStart(index) {\n    this._loopStart = index;\n    this._part.loopStart = this._indexTime(index);\n  }\n  /**\n   * The index at which the sequence should end looping\n   */\n  get loopEnd() {\n    return this._loopEnd;\n  }\n  set loopEnd(index) {\n    this._loopEnd = index;\n    if (index === 0) {\n      this._part.loopEnd = this._indexTime(this._eventsArray.length);\n    } else {\n      this._part.loopEnd = this._indexTime(index);\n    }\n  }\n  get startOffset() {\n    return this._part.startOffset;\n  }\n  set startOffset(start) {\n    this._part.startOffset = start;\n  }\n  get playbackRate() {\n    return this._part.playbackRate;\n  }\n  set playbackRate(rate) {\n    this._part.playbackRate = rate;\n  }\n  get probability() {\n    return this._part.probability;\n  }\n  set probability(prob) {\n    this._part.probability = prob;\n  }\n  get progress() {\n    return this._part.progress;\n  }\n  get humanize() {\n    return this._part.humanize;\n  }\n  set humanize(variation) {\n    this._part.humanize = variation;\n  }\n  /**\n   * The number of scheduled events\n   */\n  get length() {\n    return this._part.length;\n  }\n}","map":{"version":3,"mappings":"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","names":["TicksClass","omitFromObject","optionsFromArguments","isArray","isString","Part","ToneEvent","Sequence","constructor","getDefaults","arguments","callback","_seqCallback","bind","context","options","_subdivision","toTicks","subdivision","events","loop","loopStart","loopEnd","playbackRate","probability","humanize","mute","Object","assign","time","value","_events","s","clear","_eventsArray","_createSequence","_eventsUpdated","start","offset","_part","_indexTime","stop","toSeconds","array","Proxy","get","target","property","set","isFinite","parseInt","_rescheduleSequence","startOffset","sequence","forEach","index","eventOffset","length","startTime","add","dispose","l","_loopStart","_loopEnd","rate","prob","progress","variation"],"sources":["/Users/macbook/Desktop/Music/OwnGuitar/node_modules/tone/Tone/event/Sequence.ts"],"sourcesContent":["import { TicksClass } from \"../core/type/Ticks\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype SequenceEventDescription<T> = Array<T | Array<T | Array<T | Array<T | Array<T | T[]>>>>>;\n\ninterface SequenceOptions<T> extends Omit<ToneEventOptions<T>, \"value\"> {\n\tloopStart: number;\n\tloopEnd: number;\n\tsubdivision: Time;\n\tevents: SequenceEventDescription<T>;\n}\n\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Sequence<ValueType = any> extends ToneEvent<ValueType> {\n\n\treadonly name: string = \"Sequence\";\n\n\t/**\n\t * The subdivison of each note\n\t */\n\tprivate _subdivision: Ticks;\n\n\t/**\n\t * The object responsible for scheduling all of the events\n\t */\n\tprivate _part: Part = new Part({\n\t\tcallback: this._seqCallback.bind(this),\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * private reference to all of the sequence proxies\n\t */\n\tprivate _events: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * The proxied array\n\t */\n\tprivate _eventsArray: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * @param  callback  The callback to invoke with every note\n\t * @param  sequence  The sequence\n\t * @param  subdivision  The subdivision between which events are placed.\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tevents?: SequenceEventDescription<ValueType>,\n\t\tsubdivision?: Time,\n\t);\n\tconstructor(options?: Partial<SequenceOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n\t\tconst options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n\n\t\tthis._subdivision = this.toTicks(options.subdivision);\n\n\t\tthis.events = options.events;\n\n\t\t// set all of the values\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.probability = options.probability;\n\t\tthis.humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): SequenceOptions<any> {\n\t\treturn Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n\t\t\tevents: [],\n\t\t\tloop: true,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tsubdivision: \"8n\",\n\t\t});\n\t}\n\n\t/**\n\t * The internal callback for when an event is invoked\n\t */\n\tprivate _seqCallback(time: Seconds, value: any): void {\n\t\tif (value !== null) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * The sequence\n\t */\n\tget events(): any[] {\n\t\treturn this._events;\n\t}\n\tset events(s) {\n\t\tthis.clear();\n\t\tthis._eventsArray = s;\n\t\tthis._events = this._createSequence(this._eventsArray);\n\t\tthis._eventsUpdated();\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset index to start at\n\t */\n\tstart(time?: TransportTime, offset?: number): this {\n\t\tthis._part.start(time, offset ? this._indexTime(offset) : offset);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._part.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The subdivision of the sequence. This can only be\n\t * set in the constructor. The subdivision is the\n\t * interval between successive steps.\n\t */\n\tget subdivision(): Seconds {\n\t\treturn new TicksClass(this.context, this._subdivision).toSeconds();\n\t}\n\n\t/**\n\t * Create a sequence proxy which can be monitored to create subsequences\n\t */\n\tprivate _createSequence(array: any[]): any[] {\n\t\treturn new Proxy(array, {\n\t\t\tget: (target: any[], property: PropertyKey): any => {\n\t\t\t\t// property is index in this case\n\t\t\t\treturn target[property];\n\t\t\t},\n\t\t\tset: (target: any[], property: PropertyKey, value: any): boolean => {\n\t\t\t\tif (isString(property) && isFinite(parseInt(property, 10))) {\n\t\t\t\t\tif (isArray(value)) {\n\t\t\t\t\t\ttarget[property] = this._createSequence(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttarget[property] = value;\n\t\t\t\t}\n\t\t\t\tthis._eventsUpdated();\n\t\t\t\t// return true to accept the changes\n\t\t\t\treturn true;\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * When the sequence has changed, all of the events need to be recreated\n\t */\n\tprivate _eventsUpdated(): void {\n\t\tthis._part.clear();\n\t\tthis._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n\t\t// update the loopEnd\n\t\tthis.loopEnd = this.loopEnd;\n\t}\n\n\t/**\n\t * reschedule all of the events that need to be rescheduled\n\t */\n\tprivate _rescheduleSequence(sequence: any[], subdivision: Ticks, startOffset: Ticks): void {\n\t\tsequence.forEach((value, index) => {\n\t\t\tconst eventOffset = index * (subdivision) + startOffset;\n\t\t\tif (isArray(value)) {\n\t\t\t\tthis._rescheduleSequence(value, subdivision / value.length, eventOffset);\n\t\t\t} else {\n\t\t\t\tconst startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\t\t\t\tthis._part.add(startTime, value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get the time of the index given the Sequence's subdivision\n\t * @param  index\n\t * @return The time of that index\n\t */\n\tprivate _indexTime(index: number): Seconds {\n\t\treturn new TicksClass(this.context, index * (this._subdivision) + this.startOffset).toSeconds();\n\t}\n\n\t/**\n\t * Clear all of the events\n\t */\n\tclear(): this {\n\t\tthis._part.clear();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._part.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// PROXY CALLS\n\t//-------------------------------------\n\n\tget loop(): boolean | number {\n\t\treturn this._part.loop;\n\t}\n\tset loop(l) {\n\t\tthis._part.loop = l;\n\t}\n\n\t/**\n\t * The index at which the sequence should start looping\n\t */\n\tget loopStart(): number {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(index) {\n\t\tthis._loopStart = index;\n\t\tthis._part.loopStart = this._indexTime(index);\n\t}\n\n\t/**\n\t * The index at which the sequence should end looping\n\t */\n\tget loopEnd(): number {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(index) {\n\t\tthis._loopEnd = index;\n\t\tif (index === 0) {\n\t\t\tthis._part.loopEnd = this._indexTime(this._eventsArray.length);\n\t\t} else {\n\t\t\tthis._part.loopEnd = this._indexTime(index);\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._part.startOffset;\n\t}\n\tset startOffset(start) {\n\t\tthis._part.startOffset = start;\n\t}\n\n\tget playbackRate(): Positive {\n\t\treturn this._part.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._part.playbackRate = rate;\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._part.probability;\n\t}\n\tset probability(prob) {\n\t\tthis._part.probability = prob;\n\t}\n\n\tget progress(): NormalRange {\n\t\treturn this._part.progress;\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._part.humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._part.humanize = variation;\n\t}\n\n\t/**\n\t * The number of scheduled events\n\t */\n\tget length(): number {\n\t\treturn this._part.length;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}