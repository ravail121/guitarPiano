{"ast":null,"code":"/* global AudioBuffer */\n'use strict';\n\nvar ADSR = require('adsr');\nvar EMPTY = {};\nvar DEFAULTS = {\n  gain: 1,\n  attack: 0.01,\n  decay: 0.1,\n  sustain: 0.9,\n  release: 0.3,\n  loop: false,\n  cents: 0,\n  loopStart: 0,\n  loopEnd: 0\n};\n\n/**\n * Create a sample player.\n *\n * @param {AudioContext} ac - the audio context\n * @param {ArrayBuffer|Object<String,ArrayBuffer>} source\n * @param {Onject} options - (Optional) an options object\n * @return {player} the player\n * @example\n * var SamplePlayer = require('sample-player')\n * var ac = new AudioContext()\n * var snare = SamplePlayer(ac, <AudioBuffer>)\n * snare.play()\n */\nfunction SamplePlayer(ac, source, options) {\n  var connected = false;\n  var nextId = 0;\n  var tracked = {};\n  var out = ac.createGain();\n  out.gain.value = 1;\n  var opts = Object.assign({}, DEFAULTS, options);\n\n  /**\n   * @namespace\n   */\n  var player = {\n    context: ac,\n    out: out,\n    opts: opts\n  };\n  if (source instanceof AudioBuffer) player.buffer = source;else player.buffers = source;\n\n  /**\n   * Start a sample buffer.\n   *\n   * The returned object has a function `stop(when)` to stop the sound.\n   *\n   * @param {String} name - the name of the buffer. If the source of the\n   * SamplePlayer is one sample buffer, this parameter is not required\n   * @param {Float} when - (Optional) when to start (current time if by default)\n   * @param {Object} options - additional sample playing options\n   * @return {AudioNode} an audio node with a `stop` function\n   * @example\n   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)\n   * sample.start()\n   * sample.start(5, { gain: 0.7 }) // name not required since is only one AudioBuffer\n   * @example\n   * var drums = player(ac, { snare: <AudioBuffer>, kick: <AudioBuffer>, ... }).connect(ac.destination)\n   * drums.start('snare')\n   * drums.start('snare', 0, { gain: 0.3 })\n   */\n  player.start = function (name, when, options) {\n    // if only one buffer, reorder arguments\n    if (player.buffer && name !== null) return player.start(null, name, when);\n    var buffer = name ? player.buffers[name] : player.buffer;\n    if (!buffer) {\n      console.warn('Buffer ' + name + ' not found.');\n      return;\n    } else if (!connected) {\n      console.warn('SamplePlayer not connected to any node.');\n      return;\n    }\n    var opts = options || EMPTY;\n    when = Math.max(ac.currentTime, when || 0);\n    player.emit('start', when, name, opts);\n    var node = createNode(name, buffer, opts);\n    node.id = track(name, node);\n    node.env.start(when);\n    node.source.start(when);\n    player.emit('started', when, node.id, node);\n    if (opts.duration) node.stop(when + opts.duration);\n    return node;\n  };\n\n  // NOTE: start will be override so we can't copy the function reference\n  // this is obviously not a good design, so this code will be gone soon.\n  /**\n   * An alias for `player.start`\n   * @see player.start\n   * @since 0.3.0\n   */\n  player.play = function (name, when, options) {\n    return player.start(name, when, options);\n  };\n\n  /**\n   * Stop some or all samples\n   *\n   * @param {Float} when - (Optional) an absolute time in seconds (or currentTime\n   * if not specified)\n   * @param {Array} nodes - (Optional) an array of nodes or nodes ids to stop\n   * @return {Array} an array of ids of the stoped samples\n   *\n   * @example\n   * var longSound = player(ac, <AudioBuffer>).connect(ac.destination)\n   * longSound.start(ac.currentTime)\n   * longSound.start(ac.currentTime + 1)\n   * longSound.start(ac.currentTime + 2)\n   * longSound.stop(ac.currentTime + 3) // stop the three sounds\n   */\n  player.stop = function (when, ids) {\n    var node;\n    ids = ids || Object.keys(tracked);\n    return ids.map(function (id) {\n      node = tracked[id];\n      if (!node) return null;\n      node.stop(when);\n      return node.id;\n    });\n  };\n  /**\n   * Connect the player to a destination node\n   *\n   * @param {AudioNode} destination - the destination node\n   * @return {AudioPlayer} the player\n   * @chainable\n   * @example\n   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)\n   */\n  player.connect = function (dest) {\n    connected = true;\n    out.connect(dest);\n    return player;\n  };\n  player.emit = function (event, when, obj, opts) {\n    if (player.onevent) player.onevent(event, when, obj, opts);\n    var fn = player['on' + event];\n    if (fn) fn(when, obj, opts);\n  };\n  return player;\n\n  // =============== PRIVATE FUNCTIONS ============== //\n\n  function track(name, node) {\n    node.id = nextId++;\n    tracked[node.id] = node;\n    node.source.onended = function () {\n      var now = ac.currentTime;\n      node.source.disconnect();\n      node.env.disconnect();\n      node.disconnect();\n      player.emit('ended', now, node.id, node);\n    };\n    return node.id;\n  }\n  function createNode(name, buffer, options) {\n    var node = ac.createGain();\n    node.gain.value = 0; // the envelope will control the gain\n    node.connect(out);\n    node.env = envelope(ac, options, opts);\n    node.env.connect(node.gain);\n    node.source = ac.createBufferSource();\n    node.source.buffer = buffer;\n    node.source.connect(node);\n    node.source.loop = options.loop || opts.loop;\n    node.source.playbackRate.value = centsToRate(options.cents || opts.cents);\n    node.source.loopStart = options.loopStart || opts.loopStart;\n    node.source.loopEnd = options.loopEnd || opts.loopEnd;\n    node.stop = function (when) {\n      var time = when || ac.currentTime;\n      player.emit('stop', time, name);\n      var stopAt = node.env.stop(time);\n      node.source.stop(stopAt);\n    };\n    return node;\n  }\n}\nfunction isNum(x) {\n  return typeof x === 'number';\n}\nvar PARAMS = ['attack', 'decay', 'sustain', 'release'];\nfunction envelope(ac, options, opts) {\n  var env = ADSR(ac);\n  var adsr = options.adsr || opts.adsr;\n  PARAMS.forEach(function (name, i) {\n    if (adsr) env[name] = adsr[i];else env[name] = options[name] || opts[name];\n  });\n  env.value.value = isNum(options.gain) ? options.gain : isNum(opts.gain) ? opts.gain : 1;\n  return env;\n}\n\n/*\n * Get playback rate for a given pitch change (in cents)\n * Basic [math](http://www.birdsoft.demon.co.uk/music/samplert.htm):\n * f2 = f1 * 2^( C / 1200 )\n */\nfunction centsToRate(cents) {\n  return cents ? Math.pow(2, cents / 1200) : 1;\n}\nmodule.exports = SamplePlayer;","map":{"version":3,"names":["ADSR","require","EMPTY","DEFAULTS","gain","attack","decay","sustain","release","loop","cents","loopStart","loopEnd","SamplePlayer","ac","source","options","connected","nextId","tracked","out","createGain","value","opts","Object","assign","player","context","AudioBuffer","buffer","buffers","start","name","when","console","warn","Math","max","currentTime","emit","node","createNode","id","track","env","duration","stop","play","ids","keys","map","connect","dest","event","obj","onevent","fn","onended","now","disconnect","envelope","createBufferSource","playbackRate","centsToRate","time","stopAt","isNum","x","PARAMS","adsr","forEach","i","pow","module","exports"],"sources":["/Users/macbook/Desktop/Music/OwnGuitar/node_modules/sample-player/lib/player.js"],"sourcesContent":["/* global AudioBuffer */\n'use strict'\n\nvar ADSR = require('adsr')\n\nvar EMPTY = {}\nvar DEFAULTS = {\n  gain: 1,\n  attack: 0.01,\n  decay: 0.1,\n  sustain: 0.9,\n  release: 0.3,\n  loop: false,\n  cents: 0,\n  loopStart: 0,\n  loopEnd: 0\n}\n\n/**\n * Create a sample player.\n *\n * @param {AudioContext} ac - the audio context\n * @param {ArrayBuffer|Object<String,ArrayBuffer>} source\n * @param {Onject} options - (Optional) an options object\n * @return {player} the player\n * @example\n * var SamplePlayer = require('sample-player')\n * var ac = new AudioContext()\n * var snare = SamplePlayer(ac, <AudioBuffer>)\n * snare.play()\n */\nfunction SamplePlayer (ac, source, options) {\n  var connected = false\n  var nextId = 0\n  var tracked = {}\n  var out = ac.createGain()\n  out.gain.value = 1\n\n  var opts = Object.assign({}, DEFAULTS, options)\n\n  /**\n   * @namespace\n   */\n  var player = { context: ac, out: out, opts: opts }\n  if (source instanceof AudioBuffer) player.buffer = source\n  else player.buffers = source\n\n  /**\n   * Start a sample buffer.\n   *\n   * The returned object has a function `stop(when)` to stop the sound.\n   *\n   * @param {String} name - the name of the buffer. If the source of the\n   * SamplePlayer is one sample buffer, this parameter is not required\n   * @param {Float} when - (Optional) when to start (current time if by default)\n   * @param {Object} options - additional sample playing options\n   * @return {AudioNode} an audio node with a `stop` function\n   * @example\n   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)\n   * sample.start()\n   * sample.start(5, { gain: 0.7 }) // name not required since is only one AudioBuffer\n   * @example\n   * var drums = player(ac, { snare: <AudioBuffer>, kick: <AudioBuffer>, ... }).connect(ac.destination)\n   * drums.start('snare')\n   * drums.start('snare', 0, { gain: 0.3 })\n   */\n  player.start = function (name, when, options) {\n    // if only one buffer, reorder arguments\n    if (player.buffer && name !== null) return player.start(null, name, when)\n\n    var buffer = name ? player.buffers[name] : player.buffer\n    if (!buffer) {\n      console.warn('Buffer ' + name + ' not found.')\n      return\n    } else if (!connected) {\n      console.warn('SamplePlayer not connected to any node.')\n      return\n    }\n\n    var opts = options || EMPTY\n    when = Math.max(ac.currentTime, when || 0)\n    player.emit('start', when, name, opts)\n    var node = createNode(name, buffer, opts)\n    node.id = track(name, node)\n    node.env.start(when)\n    node.source.start(when)\n    player.emit('started', when, node.id, node)\n    if (opts.duration) node.stop(when + opts.duration)\n    return node\n  }\n\n  // NOTE: start will be override so we can't copy the function reference\n  // this is obviously not a good design, so this code will be gone soon.\n  /**\n   * An alias for `player.start`\n   * @see player.start\n   * @since 0.3.0\n   */\n  player.play = function (name, when, options) {\n    return player.start(name, when, options)\n  }\n\n  /**\n   * Stop some or all samples\n   *\n   * @param {Float} when - (Optional) an absolute time in seconds (or currentTime\n   * if not specified)\n   * @param {Array} nodes - (Optional) an array of nodes or nodes ids to stop\n   * @return {Array} an array of ids of the stoped samples\n   *\n   * @example\n   * var longSound = player(ac, <AudioBuffer>).connect(ac.destination)\n   * longSound.start(ac.currentTime)\n   * longSound.start(ac.currentTime + 1)\n   * longSound.start(ac.currentTime + 2)\n   * longSound.stop(ac.currentTime + 3) // stop the three sounds\n   */\n  player.stop = function (when, ids) {\n    var node\n    ids = ids || Object.keys(tracked)\n    return ids.map(function (id) {\n      node = tracked[id]\n      if (!node) return null\n      node.stop(when)\n      return node.id\n    })\n  }\n  /**\n   * Connect the player to a destination node\n   *\n   * @param {AudioNode} destination - the destination node\n   * @return {AudioPlayer} the player\n   * @chainable\n   * @example\n   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)\n   */\n  player.connect = function (dest) {\n    connected = true\n    out.connect(dest)\n    return player\n  }\n\n  player.emit = function (event, when, obj, opts) {\n    if (player.onevent) player.onevent(event, when, obj, opts)\n    var fn = player['on' + event]\n    if (fn) fn(when, obj, opts)\n  }\n\n  return player\n\n  // =============== PRIVATE FUNCTIONS ============== //\n\n  function track (name, node) {\n    node.id = nextId++\n    tracked[node.id] = node\n    node.source.onended = function () {\n      var now = ac.currentTime\n      node.source.disconnect()\n      node.env.disconnect()\n      node.disconnect()\n      player.emit('ended', now, node.id, node)\n    }\n    return node.id\n  }\n\n  function createNode (name, buffer, options) {\n    var node = ac.createGain()\n    node.gain.value = 0 // the envelope will control the gain\n    node.connect(out)\n\n    node.env = envelope(ac, options, opts)\n    node.env.connect(node.gain)\n\n    node.source = ac.createBufferSource()\n    node.source.buffer = buffer\n    node.source.connect(node)\n    node.source.loop = options.loop || opts.loop\n    node.source.playbackRate.value = centsToRate(options.cents || opts.cents)\n    node.source.loopStart = options.loopStart || opts.loopStart\n    node.source.loopEnd = options.loopEnd || opts.loopEnd\n    node.stop = function (when) {\n      var time = when || ac.currentTime\n      player.emit('stop', time, name)\n      var stopAt = node.env.stop(time)\n      node.source.stop(stopAt)\n    }\n    return node\n  }\n}\n\nfunction isNum (x) { return typeof x === 'number' }\nvar PARAMS = ['attack', 'decay', 'sustain', 'release']\nfunction envelope (ac, options, opts) {\n  var env = ADSR(ac)\n  var adsr = options.adsr || opts.adsr\n  PARAMS.forEach(function (name, i) {\n    if (adsr) env[name] = adsr[i]\n    else env[name] = options[name] || opts[name]\n  })\n  env.value.value = isNum(options.gain) ? options.gain\n    : isNum(opts.gain) ? opts.gain : 1\n  return env\n}\n\n/*\n * Get playback rate for a given pitch change (in cents)\n * Basic [math](http://www.birdsoft.demon.co.uk/music/samplert.htm):\n * f2 = f1 * 2^( C / 1200 )\n */\nfunction centsToRate (cents) { return cents ? Math.pow(2, cents / 1200) : 1 }\n\nmodule.exports = SamplePlayer\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}