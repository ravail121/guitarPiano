{"ast":null,"code":"// index.ts\nimport { note as props } from \"@tonaljs/core\";\nfunction isMidi(arg) {\n  return +arg >= 0 && +arg <= 127;\n}\nfunction toMidi(note) {\n  if (isMidi(note)) {\n    return +note;\n  }\n  const n = props(note);\n  return n.empty ? null : n.midi;\n}\nfunction midiToFreq(midi) {\n  let tuning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 440;\n  return Math.pow(2, (midi - 69) / 12) * tuning;\n}\nvar L2 = Math.log(2);\nvar L440 = Math.log(440);\nfunction freqToMidi(freq) {\n  const v = 12 * (Math.log(freq) - L440) / L2 + 69;\n  return Math.round(v * 100) / 100;\n}\nvar SHARPS = \"C C# D D# E F F# G G# A A# B\".split(\" \");\nvar FLATS = \"C Db D Eb E F Gb G Ab A Bb B\".split(\" \");\nfunction midiToNoteName(midi) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (isNaN(midi) || midi === -Infinity || midi === Infinity) return \"\";\n  midi = Math.round(midi);\n  const pcs = options.sharps === true ? SHARPS : FLATS;\n  const pc = pcs[midi % 12];\n  if (options.pitchClass) {\n    return pc;\n  }\n  const o = Math.floor(midi / 12) - 1;\n  return pc + o;\n}\nfunction chroma(midi) {\n  return midi % 12;\n}\nfunction pcsetFromChroma(chroma2) {\n  return chroma2.split(\"\").reduce((pcset2, val, index) => {\n    if (index < 12 && val === \"1\") pcset2.push(index);\n    return pcset2;\n  }, []);\n}\nfunction pcsetFromMidi(midi) {\n  return midi.map(chroma).sort((a, b) => a - b).filter((n, i, a) => i === 0 || n !== a[i - 1]);\n}\nfunction pcset(notes) {\n  return Array.isArray(notes) ? pcsetFromMidi(notes) : pcsetFromChroma(notes);\n}\nfunction pcsetNearest(notes) {\n  const set = pcset(notes);\n  return midi => {\n    const ch = chroma(midi);\n    for (let i = 0; i < 12; i++) {\n      if (set.includes(ch + i)) return midi + i;\n      if (set.includes(ch - i)) return midi - i;\n    }\n    return void 0;\n  };\n}\nfunction pcsetSteps(notes, tonic) {\n  const set = pcset(notes);\n  const len = set.length;\n  return step => {\n    const index = step < 0 ? (len - -step % len) % len : step % len;\n    const octaves = Math.floor(step / len);\n    return set[index] + octaves * 12 + tonic;\n  };\n}\nfunction pcsetDegrees(notes, tonic) {\n  const steps = pcsetSteps(notes, tonic);\n  return degree => {\n    if (degree === 0) return void 0;\n    return steps(degree > 0 ? degree - 1 : degree);\n  };\n}\nvar midi_default = {\n  chroma,\n  freqToMidi,\n  isMidi,\n  midiToFreq,\n  midiToNoteName,\n  pcsetNearest,\n  pcset,\n  pcsetDegrees,\n  pcsetSteps,\n  toMidi\n};\nexport { chroma, midi_default as default, freqToMidi, isMidi, midiToFreq, midiToNoteName, pcset, pcsetDegrees, pcsetNearest, pcsetSteps, toMidi };","map":{"version":3,"mappings":"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","names":["note","props","isMidi","arg","toMidi","n","empty","midi","midiToFreq","tuning","Math","pow","L2","log","L440","freqToMidi","freq","v","round","SHARPS","split","FLATS","midiToNoteName","options","isNaN","Infinity","pcs","sharps","pc","pitchClass","o","floor","chroma","pcsetFromChroma","reduce","pcset","val","index","push","pcsetFromMidi","map","sort","a","b","filter","i","notes","Array","isArray","pcsetNearest","set","ch","includes","pcsetSteps","tonic","len","length","step","octaves","pcsetDegrees","steps","degree","midi_default"],"sources":["/Users/macbook/Desktop/Music/OwnGuitar/node_modules/@tonaljs/midi/index.ts"],"sourcesContent":["import { note as props, NoteName } from \"@tonaljs/core\";\n\ntype Midi = number;\n\nexport function isMidi(arg: any): arg is Midi {\n  return +arg >= 0 && +arg <= 127;\n}\n\n/**\n * Get the note midi number (a number between 0 and 127)\n *\n * It returns undefined if not valid note name\n *\n * @function\n * @param {string|number} note - the note name or midi number\n * @return {Integer} the midi number or undefined if not valid note\n * @example\n * import { toMidi } from '@tonaljs/midi'\n * toMidi(\"C4\") // => 60\n * toMidi(60) // => 60\n * toMidi('60') // => 60\n */\nexport function toMidi(note: NoteName | number): number | null {\n  if (isMidi(note)) {\n    return +note;\n  }\n  const n = props(note);\n  return n.empty ? null : n.midi;\n}\n\n/**\n * Get the frequency in hertzs from midi number\n *\n * @param {number} midi - the note midi number\n * @param {number} [tuning = 440] - A4 tuning frequency in Hz (440 by default)\n * @return {number} the frequency or null if not valid note midi\n * @example\n * import { midiToFreq} from '@tonaljs/midi'\n * midiToFreq(69) // => 440\n */\nexport function midiToFreq(midi: number, tuning = 440): number {\n  return Math.pow(2, (midi - 69) / 12) * tuning;\n}\n\nconst L2 = Math.log(2);\nconst L440 = Math.log(440);\n\n/**\n * Get the midi number from a frequency in hertz. The midi number can\n * contain decimals (with two digits precision)\n *\n * @param {number} frequency\n * @return {number}\n * @example\n * import { freqToMidi} from '@tonaljs/midi'\n * freqToMidi(220)); //=> 57\n * freqToMidi(261.62)); //=> 60\n * freqToMidi(261)); //=> 59.96\n */\nexport function freqToMidi(freq: number): number {\n  const v = (12 * (Math.log(freq) - L440)) / L2 + 69;\n  return Math.round(v * 100) / 100;\n}\n\nexport interface ToNoteNameOptions {\n  pitchClass?: boolean;\n  sharps?: boolean;\n}\n\nconst SHARPS = \"C C# D D# E F F# G G# A A# B\".split(\" \");\nconst FLATS = \"C Db D Eb E F Gb G Ab A Bb B\".split(\" \");\n/**\n * Given a midi number, returns a note name. The altered notes will have\n * flats unless explicitly set with the optional `useSharps` parameter.\n *\n * @function\n * @param {number} midi - the midi note number\n * @param {Object} options = default: `{ sharps: false, pitchClass: false }`\n * @param {boolean} useSharps - (Optional) set to true to use sharps instead of flats\n * @return {string} the note name\n * @example\n * import { midiToNoteName } from '@tonaljs/midi'\n * midiToNoteName(61) // => \"Db4\"\n * midiToNoteName(61, { pitchClass: true }) // => \"Db\"\n * midiToNoteName(61, { sharps: true }) // => \"C#4\"\n * midiToNoteName(61, { pitchClass: true, sharps: true }) // => \"C#\"\n * // it rounds to nearest note\n * midiToNoteName(61.7) // => \"D4\"\n */\nexport function midiToNoteName(midi: number, options: ToNoteNameOptions = {}) {\n  if (isNaN(midi) || midi === -Infinity || midi === Infinity) return \"\";\n  midi = Math.round(midi);\n  const pcs = options.sharps === true ? SHARPS : FLATS;\n  const pc = pcs[midi % 12];\n  if (options.pitchClass) {\n    return pc;\n  }\n  const o = Math.floor(midi / 12) - 1;\n  return pc + o;\n}\n\nexport function chroma(midi: number): number {\n  return midi % 12;\n}\n\nfunction pcsetFromChroma(chroma: string): number[] {\n  return chroma.split(\"\").reduce((pcset, val, index) => {\n    if (index < 12 && val === \"1\") pcset.push(index);\n    return pcset;\n  }, [] as number[]);\n}\n\nfunction pcsetFromMidi(midi: number[]): number[] {\n  return midi\n    .map(chroma)\n    .sort((a, b) => a - b)\n    .filter((n, i, a) => i === 0 || n !== a[i - 1]);\n}\n\n/**\n * Given a list of midi numbers, returns the pitch class set (unique chroma numbers)\n * @param midi\n * @example\n *\n */\nexport function pcset(notes: number[] | string): number[] {\n  return Array.isArray(notes) ? pcsetFromMidi(notes) : pcsetFromChroma(notes);\n}\n\nexport function pcsetNearest(notes: number[] | string) {\n  const set = pcset(notes);\n  return (midi: number): number | undefined => {\n    const ch = chroma(midi);\n    for (let i = 0; i < 12; i++) {\n      if (set.includes(ch + i)) return midi + i;\n      if (set.includes(ch - i)) return midi - i;\n    }\n    return undefined;\n  };\n}\n\nexport function pcsetSteps(notes: number[] | string, tonic: number) {\n  const set = pcset(notes);\n  const len = set.length;\n  return (step: number): number => {\n    const index = step < 0 ? (len - (-step % len)) % len : step % len;\n    const octaves = Math.floor(step / len);\n    return set[index] + octaves * 12 + tonic;\n  };\n}\n\nexport function pcsetDegrees(notes: number[] | string, tonic: number) {\n  const steps = pcsetSteps(notes, tonic);\n  return (degree: number): number | undefined => {\n    if (degree === 0) return undefined;\n    return steps(degree > 0 ? degree - 1 : degree);\n  };\n}\n\nexport default {\n  chroma,\n  freqToMidi,\n  isMidi,\n  midiToFreq,\n  midiToNoteName,\n  pcsetNearest,\n  pcset,\n  pcsetDegrees,\n  pcsetSteps,\n  toMidi,\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}