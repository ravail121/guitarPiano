{"ast":null,"code":"import { TicksClass } from \"../type/Ticks\";\nimport { TransportEvent } from \"./TransportEvent\";\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n  /**\n   * @param transport The transport object which the event belongs to\n   */\n  constructor(transport, opts) {\n    super(transport, opts);\n    /**\n     * The ID of the current timeline event\n     */\n    this._currentId = -1;\n    /**\n     * The ID of the next timeline event\n     */\n    this._nextId = -1;\n    /**\n     * The time of the next event\n     */\n    this._nextTick = this.time;\n    /**\n     * a reference to the bound start method\n     */\n    this._boundRestart = this._restart.bind(this);\n    const options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n    this.duration = new TicksClass(transport.context, options.duration).valueOf();\n    this._interval = new TicksClass(transport.context, options.interval).valueOf();\n    this._nextTick = options.time;\n    this.transport.on(\"start\", this._boundRestart);\n    this.transport.on(\"loopStart\", this._boundRestart);\n    this.context = this.transport.context;\n    this._restart();\n  }\n  static getDefaults() {\n    return Object.assign({}, TransportEvent.getDefaults(), {\n      duration: Infinity,\n      interval: 1,\n      once: false\n    });\n  }\n  /**\n   * Invoke the callback. Returns the tick time which\n   * the next event should be scheduled at.\n   * @param  time  The AudioContext time in seconds of the event\n   */\n  invoke(time) {\n    // create more events if necessary\n    this._createEvents(time);\n    // call the super class\n    super.invoke(time);\n  }\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   */\n  _createEvents(time) {\n    // schedule the next event\n    const ticks = this.transport.getTicksAtTime(time);\n    if (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n      this._nextTick += this._interval;\n      this._currentId = this._nextId;\n      this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    }\n  }\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   */\n  _restart(time) {\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    this._nextTick = this.time;\n    const ticks = this.transport.getTicksAtTime(time);\n    if (ticks > this.time) {\n      this._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n    }\n    this._currentId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    this._nextTick += this._interval;\n    this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    this.transport.off(\"start\", this._boundRestart);\n    this.transport.off(\"loopStart\", this._boundRestart);\n    return this;\n  }\n}","map":{"version":3,"mappings":"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","names":["TicksClass","TransportEvent","TransportRepeatEvent","constructor","transport","opts","time","_restart","bind","options","Object","assign","getDefaults","duration","context","valueOf","_interval","interval","_nextTick","on","_boundRestart","Infinity","once","invoke","_createEvents","ticks","getTicksAtTime","_currentId","_nextId","scheduleOnce","toSeconds","clear","Math","ceil","dispose","off"],"sources":["/Users/macbook/Desktop/Music/OwnGuitar/node_modules/tone/Tone/core/clock/TransportRepeatEvent.ts"],"sourcesContent":["import { BaseContext } from \"../context/BaseContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: BaseContext;\n\n\t/**\n\t * @param transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportRepeatEventOptions>) {\n\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration = new TicksClass(transport.context, options.duration).valueOf();\n\t\tthis._interval = new TicksClass(transport.context, options.interval).valueOf();\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis._nextTick = this.time;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks > this.time) {\n\t\t\tthis._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n\t\t}\n\t\tthis._currentId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}