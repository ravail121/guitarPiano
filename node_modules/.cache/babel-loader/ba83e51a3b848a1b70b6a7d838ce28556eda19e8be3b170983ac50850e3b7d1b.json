{"ast":null,"code":"'use strict';\n\n// util\nfunction fillStr(s, num) {\n  return Array(num + 1).join(s);\n}\nfunction isNum(x) {\n  return typeof x === 'number';\n}\nfunction isStr(x) {\n  return typeof x === 'string';\n}\nfunction isDef(x) {\n  return typeof x !== 'undefined';\n}\nfunction midiToFreq(midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440);\n}\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/;\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nexport function regex() {\n  return REGEX;\n}\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11];\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nexport function parse(str, isTonic, tuning) {\n  if (typeof str !== 'string') return null;\n  var m = REGEX.exec(str);\n  if (!m || !isTonic && m[4]) return null;\n  var p = {\n    letter: m[1].toUpperCase(),\n    acc: m[2].replace(/x/g, '##')\n  };\n  p.pc = p.letter + p.acc;\n  p.step = (p.letter.charCodeAt(0) + 3) % 7;\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length;\n  var pos = SEMITONES[p.step] + p.alt;\n  p.chroma = pos < 0 ? 12 + pos : pos % 12;\n  if (m[3]) {\n    // has octave\n    p.oct = +m[3];\n    p.midi = pos + 12 * (p.oct + 1);\n    p.freq = midiToFreq(p.midi, tuning);\n  }\n  if (isTonic) p.tonicOf = m[4];\n  return p;\n}\nvar LETTERS = 'CDEFGAB';\nfunction accStr(n) {\n  return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n);\n}\nfunction octStr(n) {\n  return !isNum(n) ? '' : '' + n;\n}\n\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\nexport function build(s, a, o) {\n  if (s === null || typeof s === 'undefined') return null;\n  if (s.step) return build(s.step, s.alt, s.oct);\n  if (s < 0 || s > 6) return null;\n  return LETTERS.charAt(s) + accStr(a) + octStr(o);\n}\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\nexport function midi(note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note;\n  var p = parse(note);\n  return p && isDef(p.midi) ? p.midi : null;\n}\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\nexport function freq(note, tuning) {\n  var m = midi(note);\n  return m === null ? null : midiToFreq(m, tuning);\n}\nexport function letter(src) {\n  return (parse(src) || {}).letter;\n}\nexport function acc(src) {\n  return (parse(src) || {}).acc;\n}\nexport function pc(src) {\n  return (parse(src) || {}).pc;\n}\nexport function step(src) {\n  return (parse(src) || {}).step;\n}\nexport function alt(src) {\n  return (parse(src) || {}).alt;\n}\nexport function chroma(src) {\n  return (parse(src) || {}).chroma;\n}\nexport function oct(src) {\n  return (parse(src) || {}).oct;\n}","map":{"version":3,"names":["fillStr","s","num","Array","join","isNum","x","isStr","isDef","midiToFreq","midi","tuning","Math","pow","REGEX","regex","SEMITONES","parse","str","isTonic","m","exec","p","letter","toUpperCase","acc","replace","pc","step","charCodeAt","alt","length","pos","chroma","oct","freq","tonicOf","LETTERS","accStr","n","octStr","build","a","o","charAt","note","src"],"sources":["/Users/macbook/Desktop/Music/OwnGuitar/node_modules/note-parser/index.js"],"sourcesContent":["'use strict'\n\n// util\nfunction fillStr (s, num) { return Array(num + 1).join(s) }\nfunction isNum (x) { return typeof x === 'number' }\nfunction isStr (x) { return typeof x === 'string' }\nfunction isDef (x) { return typeof x !== 'undefined' }\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nexport function regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nexport function parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || (!isTonic && m[4])) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  var pos = SEMITONES[p.step] + p.alt\n  p.chroma = pos < 0 ? 12 + pos : pos % 12\n  if (m[3]) { // has octave\n    p.oct = +m[3]\n    p.midi = pos + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\nvar LETTERS = 'CDEFGAB'\nfunction accStr (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }\nfunction octStr (n) { return !isNum(n) ? '' : '' + n }\n\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\nexport function build (s, a, o) {\n  if (s === null || typeof s === 'undefined') return null\n  if (s.step) return build(s.step, s.alt, s.oct)\n  if (s < 0 || s > 6) return null\n  return LETTERS.charAt(s) + accStr(a) + octStr(o)\n}\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\nexport function midi (note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note\n  var p = parse(note)\n  return p && isDef(p.midi) ? p.midi : null\n}\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\nexport function freq (note, tuning) {\n  var m = midi(note)\n  return m === null ? null : midiToFreq(m, tuning)\n}\n\nexport function letter (src) { return (parse(src) || {}).letter }\nexport function acc (src) { return (parse(src) || {}).acc }\nexport function pc (src) { return (parse(src) || {}).pc }\nexport function step (src) { return (parse(src) || {}).step }\nexport function alt (src) { return (parse(src) || {}).alt }\nexport function chroma (src) { return (parse(src) || {}).chroma }\nexport function oct (src) { return (parse(src) || {}).oct }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}