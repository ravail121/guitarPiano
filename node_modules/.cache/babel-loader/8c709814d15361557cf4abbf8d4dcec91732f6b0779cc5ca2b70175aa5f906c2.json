{"ast":null,"code":"import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key, arg) {\n  return key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\nexport function deepMerge(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n  if (!sources.length) {\n    return target;\n  }\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (noCopy(key, source[key])) {\n        target[key] = source[key];\n      } else if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n        deepMerge(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  // @ts-ignore\n  return deepMerge(target, ...sources);\n}\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals(arrayA, arrayB) {\n  return arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments(defaults, argsArray) {\n  let keys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let objKey = arguments.length > 3 ? arguments[3] : undefined;\n  const opts = {};\n  const args = Array.from(argsArray);\n  // if the first argument is an object and has an object key\n  if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n    // if it's not part of the defaults\n    const partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n    if (!partOfDefaults) {\n      // merge that key\n      deepMerge(opts, {\n        [objKey]: args[0]\n      });\n      // remove the obj key from the keys\n      keys.splice(keys.indexOf(objKey), 1);\n      // shift the first argument off\n      args.shift();\n    }\n  }\n  if (args.length === 1 && isObject(args[0])) {\n    deepMerge(opts, args[0]);\n  } else {\n    for (let i = 0; i < keys.length; i++) {\n      if (isDefined(args[i])) {\n        opts[keys[i]] = args[i];\n      }\n    }\n  }\n  return deepMerge(defaults, opts);\n}\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance(instance) {\n  return instance.constructor.getDefaults();\n}\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg(given, fallback) {\n  if (isUndef(given)) {\n    return fallback;\n  } else {\n    return given;\n  }\n}\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject(obj, omit) {\n  omit.forEach(prop => {\n    if (Reflect.has(obj, prop)) {\n      delete obj[prop];\n    }\n  });\n  return obj;\n}","map":{"version":3,"mappings":"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","names":["isAudioBuffer","isAudioNode","isAudioParam","isDefined","isObject","isUndef","noCopy","key","arg","deepMerge","target","sources","length","source","shift","Object","assign","deepEquals","arrayA","arrayB","every","element","index","optionsFromArguments","defaults","argsArray","keys","objKey","opts","args","Array","from","Reflect","has","partOfDefaults","some","splice","indexOf","i","getDefaultsFromInstance","instance","constructor","getDefaults","defaultArg","given","fallback","omitFromObject","obj","omit","forEach","prop"],"sources":["/Users/macbook/Desktop/Music/OwnGuitar/node_modules/tone/Tone/core/util/Defaults.ts"],"sourcesContent":["import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n\ntype BaseToneOptions = import(\"../Tone\").BaseToneOptions;\n\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key: string, arg: any): boolean {\n\treturn key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\n\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge<T>(target: T): T;\nexport function deepMerge<T, U>(target: T, source1: U): T & U;\nexport function deepMerge<T, U, V>(target: T, source1: U, source2: V): T & U & V;\nexport function deepMerge<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function deepMerge(target: any, ...sources: any[]): any {\n\tif (!sources.length) {\n\t\treturn target; \n\t}\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (noCopy(key, source[key])) {\n\t\t\t\ttarget[key] = source[key];\n\t\t\t} else if (isObject(source[key])) {\n\t\t\t\tif (!target[key]) {\n\t\t\t\t\tObject.assign(target, { [key]: {} }); \n\t\t\t\t}\n\t\t\t\tdeepMerge(target[key], source[key] as any);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] as any });\n\t\t\t}\n\t\t}\n\t}\n\t// @ts-ignore\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals<T>(arrayA: T[], arrayB: T[]): boolean {\n\treturn arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments<T extends object>(\n\tdefaults: T,\n\targsArray: IArguments,\n\tkeys: Array<keyof T> = [],\n\tobjKey?: keyof T,\n): T {\n\tconst opts: Partial<T> = {};\n\tconst args = Array.from(argsArray);\n\t// if the first argument is an object and has an object key\n\tif (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n\t\t// if it's not part of the defaults\n\t\tconst partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n\t\tif (!partOfDefaults) {\n\t\t\t// merge that key\n\t\t\tdeepMerge(opts, { [objKey]: args[0] });\n\t\t\t// remove the obj key from the keys\n\t\t\tkeys.splice(keys.indexOf(objKey), 1);\n\t\t\t// shift the first argument off\n\t\t\targs.shift();\n\t\t}\n\t}\n\tif (args.length === 1 && isObject(args[0])) {\n\t\tdeepMerge(opts, args[0]);\n\t} else {\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tif (isDefined(args[i])) {\n\t\t\t\topts[keys[i]] = args[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn deepMerge(defaults, opts);\n}\n\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance<T>(instance: T): BaseToneOptions {\n\ttype ToneClass = {\n\t\tconstructor: ToneClass;\n\t\tgetDefaults: () => BaseToneOptions;\n\t} & T;\n\n\treturn (instance as ToneClass).constructor.getDefaults();\n}\n\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg<T>(given: T, fallback: T): T {\n\tif (isUndef(given)) {\n\t\treturn fallback;\n\t} else {\n\t\treturn given;\n\t}\n}\n\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject<T extends object, O extends string[]>(obj: T, omit: O): Omit<T, keyof O> {\n\tomit.forEach(prop => {\n\t\tif (Reflect.has(obj, prop)) {\n\t\t\tdelete obj[prop];\n\t\t}\n\t});\n\treturn obj;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}