{"ast":null,"code":"// index.ts\nimport { coordToInterval, distance as dist, interval as props } from \"@tonaljs/core\";\nfunction names() {\n  return \"1P 2M 3M 4P 5P 6m 7m\".split(\" \");\n}\nvar get = props;\nvar name = name2 => props(name2).name;\nvar semitones = name2 => props(name2).semitones;\nvar quality = name2 => props(name2).q;\nvar num = name2 => props(name2).num;\nfunction simplify(name2) {\n  const i = props(name2);\n  return i.empty ? \"\" : i.simple + i.q;\n}\nfunction invert(name2) {\n  const i = props(name2);\n  if (i.empty) {\n    return \"\";\n  }\n  const step = (7 - i.step) % 7;\n  const alt = i.type === \"perfectable\" ? -i.alt : -(i.alt + 1);\n  return props({\n    step,\n    alt,\n    oct: i.oct,\n    dir: i.dir\n  }).name;\n}\nvar IN = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7];\nvar IQ = \"P m M m M P d P m M m M\".split(\" \");\nfunction fromSemitones(semitones2) {\n  const d = semitones2 < 0 ? -1 : 1;\n  const n = Math.abs(semitones2);\n  const c = n % 12;\n  const o = Math.floor(n / 12);\n  return d * (IN[c] + 7 * o) + IQ[c];\n}\nvar distance = dist;\nvar add = combinator((a, b) => [a[0] + b[0], a[1] + b[1]]);\nvar addTo = interval => other => add(interval, other);\nvar substract = combinator((a, b) => [a[0] - b[0], a[1] - b[1]]);\nfunction transposeFifths(interval, fifths) {\n  const ivl = get(interval);\n  if (ivl.empty) return \"\";\n  const [nFifths, nOcts, dir] = ivl.coord;\n  return coordToInterval([nFifths + fifths, nOcts, dir]).name;\n}\nvar interval_default = {\n  names,\n  get,\n  name,\n  num,\n  semitones,\n  quality,\n  fromSemitones,\n  distance,\n  invert,\n  simplify,\n  add,\n  addTo,\n  substract,\n  transposeFifths\n};\nfunction combinator(fn) {\n  return (a, b) => {\n    const coordA = props(a).coord;\n    const coordB = props(b).coord;\n    if (coordA && coordB) {\n      const coord = fn(coordA, coordB);\n      return coordToInterval(coord).name;\n    }\n  };\n}\nexport { add, addTo, interval_default as default, distance, fromSemitones, get, invert, name, names, num, quality, semitones, simplify, substract, transposeFifths };","map":{"version":3,"mappings":";AAAA,SACEA,iBACAC,YAAYC,MACZC,YAAYC,aAKP;AAKA,SAASC,QAAwB;EACtC,OAAO,uBAAuBC,MAAM,GAAG;AACzC;AASO,IAAMC,MAAMH;AAWZ,IAAMI,OAAQA,SAAiBJ,MAAMI,KAAI,EAAEA;AAQ3C,IAAMC,YAAaD,SAAiBJ,MAAMI,KAAI,EAAEC;AAQhD,IAAMC,UAAWF,SAAiBJ,MAAMI,KAAI,EAAEG;AAQ9C,IAAMC,MAAOJ,SAAiBJ,MAAMI,KAAI,EAAEI;AAgB1C,SAASC,SAASL,OAAkC;EACzD,MAAMM,IAAIV,MAAMI,KAAI;EACpB,OAAOM,EAAEC,QAAQ,KAAKD,EAAEE,SAASF,EAAEH;AACrC;AAeO,SAASM,OAAOT,OAAkC;EACvD,MAAMM,IAAIV,MAAMI,KAAI;EACpB,IAAIM,EAAEC,OAAO;IACX,OAAO;EACT;EACA,MAAMG,QAAQ,IAAIJ,EAAEI,QAAQ;EAC5B,MAAMC,MAAML,EAAEM,SAAS,gBAAgB,CAACN,EAAEK,MAAM,EAAEL,EAAEK,MAAM;EAC1D,OAAOf,MAAM;IAAEc;IAAMC;IAAKE,KAAKP,EAAEO;IAAKC,KAAKR,EAAEQ;EAAI,CAAC,EAAEd;AACtD;AAGA,IAAMe,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAE9C,IAAMC,KAAK,0BAA0BlB,MAAM,GAAG;AAYvC,SAASmB,cAAchB,YAAiC;EAC7D,MAAMiB,IAAIjB,aAAY,IAAI,KAAK;EAC/B,MAAMkB,IAAIC,KAAKC,IAAIpB,UAAS;EAC5B,MAAMqB,IAAIH,IAAI;EACd,MAAMI,IAAIH,KAAKI,MAAML,IAAI,EAAE;EAC3B,OAAOD,KAAKH,GAAGO,KAAK,IAAIC,KAAKP,GAAGM;AAClC;AAQO,IAAM7B,WAAWC;AAYjB,IAAM+B,MAAMC,WAAW,CAACC,GAAGC,MAAM,CAACD,EAAE,KAAKC,EAAE,IAAID,EAAE,KAAKC,EAAE,EAAE,CAAC;AAS3D,IAAMC,QAASlC,YAAsBmC,SAC1CL,IAAI9B,UAAUmC,KAAK;AAad,IAAMC,YAAYL,WAAW,CAACC,GAAGC,MAAM,CAACD,EAAE,KAAKC,EAAE,IAAID,EAAE,KAAKC,EAAE,EAAE,CAAC;AAEjE,SAASI,gBACdrC,UACAsC,QACc;EACd,MAAMC,MAAMnC,IAAIJ,QAAQ;EACxB,IAAIuC,IAAI3B,OAAO,OAAO;EAEtB,MAAM,CAAC4B,SAASC,OAAOtB,GAAG,IAAIoB,IAAIG;EAClC,OAAO7C,gBAAgB,CAAC2C,UAAUF,QAAQG,OAAOtB,GAAG,CAAC,EAAEd;AACzD;AAEA,IAAOsC,mBAAQ;EACbzC;EACAE;EACAC;EACAI;EACAH;EACAC;EACAe;EACAxB;EACAgB;EACAJ;EACAoB;EACAI;EACAE;EACAC;AACF;AASA,SAASN,WAAWa,IAAe;EACjC,OAAO,CAACZ,GAAiBC,MAA8C;IACrE,MAAMY,SAAS5C,MAAM+B,CAAC,EAAEU;IACxB,MAAMI,SAAS7C,MAAMgC,CAAC,EAAES;IACxB,IAAIG,UAAUC,QAAQ;MACpB,MAAMJ,QAAQE,GAAGC,QAAQC,MAAM;MAC/B,OAAOjD,gBAAgB6C,KAAK,EAAErC;IAChC;EACF;AACF","names":["coordToInterval","distance","dist","interval","props","names","split","get","name","semitones","quality","q","num","simplify","i","empty","simple","invert","step","alt","type","oct","dir","IN","IQ","fromSemitones","d","n","Math","abs","c","o","floor","add","combinator","a","b","addTo","other","substract","transposeFifths","fifths","ivl","nFifths","nOcts","coord","interval_default","fn","coordA","coordB"],"sources":["/Users/macbook/Desktop/Music/OwnGuitar/node_modules/@tonaljs/interval/index.ts"],"sourcesContent":["import {\n  coordToInterval,\n  distance as dist,\n  interval as props,\n  IntervalCoordinates,\n  IntervalName,\n  NoteCoordinates,\n  tokenizeInterval as tokenize,\n} from \"@tonaljs/core\";\n\n/**\n * Get the natural list of names\n */\nexport function names(): IntervalName[] {\n  return \"1P 2M 3M 4P 5P 6m 7m\".split(\" \");\n}\n\n/**\n * Get properties of an interval\n *\n * @function\n * @example\n * Interval.get('P4') // => {\"alt\": 0,  \"dir\": 1,  \"name\": \"4P\", \"num\": 4, \"oct\": 0, \"q\": \"P\", \"semitones\": 5, \"simple\": 4, \"step\": 3, \"type\": \"perfectable\"}\n */\nexport const get = props;\n\n/**\n * Get name of an interval\n *\n * @function\n * @example\n * Interval.name('4P') // => \"4P\"\n * Interval.name('P4') // => \"4P\"\n * Interval.name('C4') // => \"\"\n */\nexport const name = (name: string) => props(name).name;\n\n/**\n * Get semitones of an interval\n * @function\n * @example\n * Interval.semitones('P4') // => 5\n */\nexport const semitones = (name: string) => props(name).semitones;\n\n/**\n * Get quality of an interval\n * @function\n * @example\n * Interval.quality('P4') // => \"P\"\n */\nexport const quality = (name: string) => props(name).q;\n\n/**\n * Get number of an interval\n * @function\n * @example\n * Interval.num('P4') // => 4\n */\nexport const num = (name: string) => props(name).num;\n\n/**\n * Get the simplified version of an interval.\n *\n * @function\n * @param {string} interval - the interval to simplify\n * @return {string} the simplified interval\n *\n * @example\n * Interval.simplify(\"9M\") // => \"2M\"\n * Interval.simplify(\"2M\") // => \"2M\"\n * Interval.simplify(\"-2M\") // => \"7m\"\n * [\"8P\", \"9M\", \"10M\", \"11P\", \"12P\", \"13M\", \"14M\", \"15P\"].map(Interval.simplify)\n * // => [ \"8P\", \"2M\", \"3M\", \"4P\", \"5P\", \"6M\", \"7M\", \"8P\" ]\n */\nexport function simplify(name: IntervalName): IntervalName {\n  const i = props(name);\n  return i.empty ? \"\" : i.simple + i.q;\n}\n\n/**\n * Get the inversion (https://en.wikipedia.org/wiki/Inversion_(music)#Intervals)\n * of an interval.\n *\n * @function\n * @param {string} interval - the interval to invert in interval shorthand\n * notation or interval array notation\n * @return {string} the inverted interval\n *\n * @example\n * Interval.invert(\"3m\") // => \"6M\"\n * Interval.invert(\"2M\") // => \"7m\"\n */\nexport function invert(name: IntervalName): IntervalName {\n  const i = props(name);\n  if (i.empty) {\n    return \"\";\n  }\n  const step = (7 - i.step) % 7;\n  const alt = i.type === \"perfectable\" ? -i.alt : -(i.alt + 1);\n  return props({ step, alt, oct: i.oct, dir: i.dir }).name;\n}\n\n// interval numbers\nconst IN = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7];\n// interval qualities\nconst IQ = \"P m M m M P d P m M m M\".split(\" \");\n\n/**\n * Get interval name from semitones number. Since there are several interval\n * names for the same number, the name it's arbitrary, but deterministic.\n *\n * @param {Integer} num - the number of semitones (can be negative)\n * @return {string} the interval name\n * @example\n * Interval.fromSemitones(7) // => \"5P\"\n * Interval.fromSemitones(-7) // => \"-5P\"\n */\nexport function fromSemitones(semitones: number): IntervalName {\n  const d = semitones < 0 ? -1 : 1;\n  const n = Math.abs(semitones);\n  const c = n % 12;\n  const o = Math.floor(n / 12);\n  return d * (IN[c] + 7 * o) + IQ[c];\n}\n\n/**\n * Find interval between two notes\n *\n * @example\n * Interval.distance(\"C4\", \"G4\"); // => \"5P\"\n */\nexport const distance = dist;\n\n/**\n * Adds two intervals\n *\n * @function\n * @param {string} interval1\n * @param {string} interval2\n * @return {string} the added interval name\n * @example\n * Interval.add(\"3m\", \"5P\") // => \"7m\"\n */\nexport const add = combinator((a, b) => [a[0] + b[0], a[1] + b[1]]);\n\n/**\n * Returns a function that adds an interval\n *\n * @function\n * @example\n * ['1P', '2M', '3M'].map(Interval.addTo('5P')) // => [\"5P\", \"6M\", \"7M\"]\n */\nexport const addTo = (interval: string) => (other: string) =>\n  add(interval, other);\n\n/**\n * Subtracts two intervals\n *\n * @function\n * @param {string} minuendInterval\n * @param {string} subtrahendInterval\n * @return {string} the substracted interval name\n * @example\n * Interval.substract('5P', '3M') // => '3m'\n * Interval.substract('3M', '5P') // => '-3m'\n */\nexport const substract = combinator((a, b) => [a[0] - b[0], a[1] - b[1]]);\n\nexport function transposeFifths(\n  interval: IntervalName,\n  fifths: number\n): IntervalName {\n  const ivl = get(interval);\n  if (ivl.empty) return \"\";\n\n  const [nFifths, nOcts, dir] = ivl.coord;\n  return coordToInterval([nFifths + fifths, nOcts, dir]).name;\n}\n\nexport default {\n  names,\n  get,\n  name,\n  num,\n  semitones,\n  quality,\n  fromSemitones,\n  distance,\n  invert,\n  simplify,\n  add,\n  addTo,\n  substract,\n  transposeFifths,\n};\n\n//// PRIVATE ////\n\ntype Operation = (\n  a: IntervalCoordinates,\n  b: IntervalCoordinates\n) => NoteCoordinates;\n\nfunction combinator(fn: Operation) {\n  return (a: IntervalName, b: IntervalName): IntervalName | undefined => {\n    const coordA = props(a).coord;\n    const coordB = props(b).coord;\n    if (coordA && coordB) {\n      const coord = fn(coordA, coordB);\n      return coordToInterval(coord).name;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}