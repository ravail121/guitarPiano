{"ast":null,"code":"import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\nexport class Emitter extends Tone {\n  constructor() {\n    super(...arguments);\n    this.name = \"Emitter\";\n  }\n  /**\n   * Bind a callback to a specific event.\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n  on(event, callback) {\n    // split the event\n    const events = event.split(/\\W+/);\n    events.forEach(eventName => {\n      if (isUndef(this._events)) {\n        this._events = {};\n      }\n      if (!this._events.hasOwnProperty(eventName)) {\n        this._events[eventName] = [];\n      }\n      this._events[eventName].push(callback);\n    });\n    return this;\n  }\n  /**\n   * Bind a callback which is only invoked once\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n  once(event, callback) {\n    var _this = this;\n    const boundCallback = function () {\n      // invoke the callback\n      callback(...arguments);\n      // remove the event\n      _this.off(event, boundCallback);\n    };\n    this.on(event, boundCallback);\n    return this;\n  }\n  /**\n   * Remove the event listener.\n   * @param  event     The event to stop listening to.\n   * @param  callback  The callback which was bound to the event with Emitter.on.\n   *                   If no callback is given, all callbacks events are removed.\n   */\n  off(event, callback) {\n    const events = event.split(/\\W+/);\n    events.forEach(eventName => {\n      if (isUndef(this._events)) {\n        this._events = {};\n      }\n      if (this._events.hasOwnProperty(event)) {\n        if (isUndef(callback)) {\n          this._events[event] = [];\n        } else {\n          const eventList = this._events[event];\n          for (let i = eventList.length - 1; i >= 0; i--) {\n            if (eventList[i] === callback) {\n              eventList.splice(i, 1);\n            }\n          }\n        }\n      }\n    });\n    return this;\n  }\n  /**\n   * Invoke all of the callbacks bound to the event\n   * with any arguments passed in.\n   * @param  event  The name of the event.\n   * @param args The arguments to pass to the functions listening.\n   */\n  emit(event) {\n    if (this._events) {\n      if (this._events.hasOwnProperty(event)) {\n        const eventList = this._events[event].slice(0);\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        for (let i = 0, len = eventList.length; i < len; i++) {\n          eventList[i].apply(this, args);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Add Emitter functions (on/off/emit) to the object\n   */\n  static mixin(constr) {\n    // instance._events = {};\n    [\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n      const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);\n      Object.defineProperty(constr.prototype, name, property);\n    });\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    this._events = undefined;\n    return this;\n  }\n}","map":{"version":3,"mappings":"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","names":["Tone","isUndef","Emitter","constructor","on","event","callback","events","split","forEach","eventName","_events","hasOwnProperty","push","once","boundCallback","off","eventList","i","length","splice","emit","slice","args","len","apply","mixin","constr","name","property","Object","getOwnPropertyDescriptor","prototype","defineProperty","dispose","undefined"],"sources":["/Users/macbook/Desktop/Music/OwnGuitar/node_modules/tone/Tone/core/util/Emitter.ts"],"sourcesContent":["import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\n\treadonly name: string = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t * Bind a callback to a specific event.\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Bind a callback which is only invoked once\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[]) => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove the event listener.\n\t * @param  event     The event to stop listening to.\n\t * @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                   If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[event] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[event];\n\t\t\t\t\tfor (let i = eventList.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke all of the callbacks bound to the event\n\t * with any arguments passed in.\n\t * @param  event  The name of the event.\n\t * @param args The arguments to pass to the functions listening.\n\t */\n\temit(event, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(Emitter.prototype, name) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}