{"ast":null,"code":"import { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const part = new Tone.Part(((time, note) => {\n * \t// the notes given as the second element in the array\n * \t// will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }), [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * Tone.Transport.start();\n * @example\n * const synth = new Tone.Synth().toDestination();\n * // use an array of objects as long as the object has a \"time\" attribute\n * const part = new Tone.Part(((time, value) => {\n * \t// the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }), [{ time: 0, note: \"C3\", velocity: 0.9 },\n * \t{ time: \"0:2\", note: \"C4\", velocity: 0.5 }\n * ]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Part extends ToneEvent {\n  constructor() {\n    super(optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n    this.name = \"Part\";\n    /**\n     * Tracks the scheduled events\n     */\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * The events that belong to this part\n     */\n    this._events = new Set();\n    const options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]);\n    // make sure things are assigned in the right order\n    this._state.increasing = true;\n    // add the events\n    options.events.forEach(event => {\n      if (isArray(event)) {\n        this.add(event[0], event[1]);\n      } else {\n        this.add(event);\n      }\n    });\n  }\n  static getDefaults() {\n    return Object.assign(ToneEvent.getDefaults(), {\n      events: []\n    });\n  }\n  /**\n   * Start the part at the given time.\n   * @param  time    When to start the part.\n   * @param  offset  The offset from the start of the part to begin playing at.\n   */\n  start(time, offset) {\n    const ticks = this.toTicks(time);\n    if (this._state.getValueAtTime(ticks) !== \"started\") {\n      offset = defaultArg(offset, this._loop ? this._loopStart : 0);\n      if (this._loop) {\n        offset = defaultArg(offset, this._loopStart);\n      } else {\n        offset = defaultArg(offset, 0);\n      }\n      const computedOffset = this.toTicks(offset);\n      this._state.add({\n        id: -1,\n        offset: computedOffset,\n        state: \"started\",\n        time: ticks\n      });\n      this._forEach(event => {\n        this._startNote(event, ticks, computedOffset);\n      });\n    }\n    return this;\n  }\n  /**\n   * Start the event in the given event at the correct time given\n   * the ticks and offset and looping.\n   * @param  event\n   * @param  ticks\n   * @param  offset\n   */\n  _startNote(event, ticks, offset) {\n    ticks -= offset;\n    if (this._loop) {\n      if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n        if (event.startOffset < offset) {\n          // start it on the next loop\n          ticks += this._getLoopDuration();\n        }\n        event.start(new TicksClass(this.context, ticks));\n      } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n        event.loop = false;\n        event.start(new TicksClass(this.context, ticks));\n      }\n    } else if (event.startOffset >= offset) {\n      event.start(new TicksClass(this.context, ticks));\n    }\n  }\n  get startOffset() {\n    return this._startOffset;\n  }\n  set startOffset(offset) {\n    this._startOffset = offset;\n    this._forEach(event => {\n      event.startOffset += this._startOffset;\n    });\n  }\n  /**\n   * Stop the part at the given time.\n   * @param  time  When to stop the part.\n   */\n  stop(time) {\n    const ticks = this.toTicks(time);\n    this._state.cancel(ticks);\n    this._state.setStateAtTime(\"stopped\", ticks);\n    this._forEach(event => {\n      event.stop(time);\n    });\n    return this;\n  }\n  /**\n   * Get/Set an Event's value at the given time.\n   * If a value is passed in and no event exists at\n   * the given time, one will be created with that value.\n   * If two events are at the same time, the first one will\n   * be returned.\n   * @example\n   * const part = new Tone.Part();\n   * part.at(\"1m\"); // returns the part at the first measure\n   * part.at(\"2m\", \"C2\"); // set the value at \"2m\" to C2.\n   * // if an event didn't exist at that time, it will be created.\n   * @param time The time of the event to get or set.\n   * @param value If a value is passed in, the value of the event at the given time will be set to it.\n   */\n  at(time, value) {\n    const timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n    const tickTime = new TicksClass(this.context, 1).toSeconds();\n    const iterator = this._events.values();\n    let result = iterator.next();\n    while (!result.done) {\n      const event = result.value;\n      if (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n        if (isDefined(value)) {\n          event.value = value;\n        }\n        return event;\n      }\n      result = iterator.next();\n    }\n    // if there was no event at that time, create one\n    if (isDefined(value)) {\n      this.add(time, value);\n      // return the new event\n      return this.at(time);\n    } else {\n      return null;\n    }\n  }\n  add(time, value) {\n    // extract the parameters\n    if (time instanceof Object && Reflect.has(time, \"time\")) {\n      value = time;\n      time = value.time;\n    }\n    const ticks = this.toTicks(time);\n    let event;\n    if (value instanceof ToneEvent) {\n      event = value;\n      event.callback = this._tick.bind(this);\n    } else {\n      event = new ToneEvent({\n        callback: this._tick.bind(this),\n        context: this.context,\n        value\n      });\n    }\n    // the start offset\n    event.startOffset = ticks;\n    // initialize the values\n    event.set({\n      humanize: this.humanize,\n      loop: this.loop,\n      loopEnd: this.loopEnd,\n      loopStart: this.loopStart,\n      playbackRate: this.playbackRate,\n      probability: this.probability\n    });\n    this._events.add(event);\n    // start the note if it should be played right now\n    this._restartEvent(event);\n    return this;\n  }\n  /**\n   * Restart the given event\n   */\n  _restartEvent(event) {\n    this._state.forEach(stateEvent => {\n      if (stateEvent.state === \"started\") {\n        this._startNote(event, stateEvent.time, stateEvent.offset);\n      } else {\n        // stop the note\n        event.stop(new TicksClass(this.context, stateEvent.time));\n      }\n    });\n  }\n  remove(time, value) {\n    // extract the parameters\n    if (isObject(time) && time.hasOwnProperty(\"time\")) {\n      value = time;\n      time = value.time;\n    }\n    time = this.toTicks(time);\n    this._events.forEach(event => {\n      if (event.startOffset === time) {\n        if (isUndef(value) || isDefined(value) && event.value === value) {\n          this._events.delete(event);\n          event.dispose();\n        }\n      }\n    });\n    return this;\n  }\n  /**\n   * Remove all of the notes from the group.\n   */\n  clear() {\n    this._forEach(event => event.dispose());\n    this._events.clear();\n    return this;\n  }\n  /**\n   * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n   * @param after The time after which to cancel the scheduled events.\n   */\n  cancel(after) {\n    this._forEach(event => event.cancel(after));\n    this._state.cancel(this.toTicks(after));\n    return this;\n  }\n  /**\n   * Iterate over all of the events\n   */\n  _forEach(callback) {\n    if (this._events) {\n      this._events.forEach(event => {\n        if (event instanceof Part) {\n          event._forEach(callback);\n        } else {\n          callback(event);\n        }\n      });\n    }\n    return this;\n  }\n  /**\n   * Set the attribute of all of the events\n   * @param  attr  the attribute to set\n   * @param  value      The value to set it to\n   */\n  _setAll(attr, value) {\n    this._forEach(event => {\n      event[attr] = value;\n    });\n  }\n  /**\n   * Internal tick method\n   * @param  time  The time of the event in seconds\n   */\n  _tick(time, value) {\n    if (!this.mute) {\n      this.callback(time, value);\n    }\n  }\n  /**\n   * Determine if the event should be currently looping\n   * given the loop boundries of this Part.\n   * @param  event  The event to test\n   */\n  _testLoopBoundries(event) {\n    if (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n      event.cancel(0);\n    } else if (event.state === \"stopped\") {\n      // reschedule it if it's stopped\n      this._restartEvent(event);\n    }\n  }\n  get probability() {\n    return this._probability;\n  }\n  set probability(prob) {\n    this._probability = prob;\n    this._setAll(\"probability\", prob);\n  }\n  get humanize() {\n    return this._humanize;\n  }\n  set humanize(variation) {\n    this._humanize = variation;\n    this._setAll(\"humanize\", variation);\n  }\n  /**\n   * If the part should loop or not\n   * between Part.loopStart and\n   * Part.loopEnd. If set to true,\n   * the part will loop indefinitely,\n   * if set to a number greater than 1\n   * it will play a specific number of\n   * times, if set to false, 0 or 1, the\n   * part will only play once.\n   * @example\n   * const part = new Tone.Part();\n   * // loop the part 8 times\n   * part.loop = 8;\n   */\n  get loop() {\n    return this._loop;\n  }\n  set loop(loop) {\n    this._loop = loop;\n    this._forEach(event => {\n      event.loopStart = this.loopStart;\n      event.loopEnd = this.loopEnd;\n      event.loop = loop;\n      this._testLoopBoundries(event);\n    });\n  }\n  /**\n   * The loopEnd point determines when it will\n   * loop if Part.loop is true.\n   */\n  get loopEnd() {\n    return new TicksClass(this.context, this._loopEnd).toSeconds();\n  }\n  set loopEnd(loopEnd) {\n    this._loopEnd = this.toTicks(loopEnd);\n    if (this._loop) {\n      this._forEach(event => {\n        event.loopEnd = loopEnd;\n        this._testLoopBoundries(event);\n      });\n    }\n  }\n  /**\n   * The loopStart point determines when it will\n   * loop if Part.loop is true.\n   */\n  get loopStart() {\n    return new TicksClass(this.context, this._loopStart).toSeconds();\n  }\n  set loopStart(loopStart) {\n    this._loopStart = this.toTicks(loopStart);\n    if (this._loop) {\n      this._forEach(event => {\n        event.loopStart = this.loopStart;\n        this._testLoopBoundries(event);\n      });\n    }\n  }\n  /**\n   * The playback rate of the part\n   */\n  get playbackRate() {\n    return this._playbackRate;\n  }\n  set playbackRate(rate) {\n    this._playbackRate = rate;\n    this._setAll(\"playbackRate\", rate);\n  }\n  /**\n   * The number of scheduled notes in the part.\n   */\n  get length() {\n    return this._events.size;\n  }\n  dispose() {\n    super.dispose();\n    this.clear();\n    return this;\n  }\n}","map":{"version":3,"mappings":"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","names":["TicksClass","TransportTimeClass","defaultArg","optionsFromArguments","StateTimeline","isArray","isDefined","isObject","isUndef","ToneEvent","Part","constructor","getDefaults","arguments","Set","options","_state","increasing","events","forEach","event","add","Object","assign","start","time","offset","ticks","toTicks","getValueAtTime","_loop","_loopStart","computedOffset","id","state","_forEach","_startNote","startOffset","_loopEnd","_getLoopDuration","context","loop","_startOffset","stop","cancel","setStateAtTime","at","value","timeInTicks","tickTime","toSeconds","iterator","_events","values","result","next","done","Math","abs","Reflect","has","callback","_tick","bind","set","humanize","loopEnd","loopStart","playbackRate","probability","_restartEvent","stateEvent","remove","hasOwnProperty","delete","dispose","clear","after","_setAll","attr","mute","_testLoopBoundries","_probability","prob","_humanize","variation","_playbackRate","rate","length","size"],"sources":["/Users/macbook/Desktop/Music/OwnGuitar/node_modules/tone/Tone/event/Part.ts"],"sourcesContent":["import { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype CallbackType<T> =\n\tT extends {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t} ? T :\n\t\tT extends ArrayLike<any> ? T[1] :\n\t\t\tT extends Time ? null : never;\n\ninterface PartOptions<T> extends Omit<ToneEventOptions<CallbackType<T>>, \"value\"> {\n\tevents: T[];\n}\n\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const part = new Tone.Part(((time, note) => {\n * \t// the notes given as the second element in the array\n * \t// will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }), [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * Tone.Transport.start();\n * @example\n * const synth = new Tone.Synth().toDestination();\n * // use an array of objects as long as the object has a \"time\" attribute\n * const part = new Tone.Part(((time, value) => {\n * \t// the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }), [{ time: 0, note: \"C3\", velocity: 0.9 },\n * \t{ time: \"0:2\", note: \"C4\", velocity: 0.5 }\n * ]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Part<ValueType = any> extends ToneEvent<ValueType> {\n\n\treadonly name: string = \"Part\";\n\n\t/**\n\t * Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number;\n\t\toffset: number;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The events that belong to this part\n\t */\n\tprivate _events: Set<ToneEvent> = new Set();\n\n\t/**\n\t * @param callback The callback to invoke on each event\n\t * @param events the array of events\n\t */\n\tconstructor(callback?: ToneEventCallback<CallbackType<ValueType>>, value?: ValueType[]);\n\tconstructor(options?: Partial<PartOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n\t\tconst options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]);\n\n\t\t// make sure things are assigned in the right order\n\t\tthis._state.increasing = true;\n\n\t\t// add the events\n\t\toptions.events.forEach(event => {\n\t\t\tif (isArray(event)) {\n\t\t\t\tthis.add(event[0], event[1]);\n\t\t\t} else {\n\t\t\t\tthis.add(event);\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic getDefaults(): PartOptions<any> {\n\t\treturn Object.assign(ToneEvent.getDefaults(), {\n\t\t\tevents: [],\n\t\t});\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset from the start of the part to begin playing at.\n\t */\n\tstart(time?: TransportTime, offset?: Time): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) !== \"started\") {\n\t\t\toffset = defaultArg(offset, this._loop ? this._loopStart : 0);\n\t\t\tif (this._loop) {\n\t\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t\t} else {\n\t\t\t\toffset = defaultArg(offset, 0);\n\t\t\t}\n\t\t\tconst computedOffset = this.toTicks(offset);\n\t\t\tthis._state.add({\n\t\t\t\tid: -1,\n\t\t\t\toffset: computedOffset,\n\t\t\t\tstate: \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._forEach(event => {\n\t\t\t\tthis._startNote(event, ticks, computedOffset);\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the event in the given event at the correct time given\n\t * the ticks and offset and looping.\n\t * @param  event\n\t * @param  ticks\n\t * @param  offset\n\t */\n\tprivate _startNote(event: ToneEvent, ticks: Ticks, offset: Ticks): void {\n\t\tticks -= offset;\n\t\tif (this._loop) {\n\t\t\tif (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n\t\t\t\tif (event.startOffset < offset) {\n\t\t\t\t\t// start it on the next loop\n\t\t\t\t\tticks += this._getLoopDuration();\n\t\t\t\t}\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t} else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n\t\t\t\tevent.loop = false;\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t}\n\t\t} else if (event.startOffset >= offset) {\n\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t\tthis._forEach(event => {\n\t\t\tevent.startOffset += this._startOffset;\n\t\t});\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.cancel(ticks);\n\t\tthis._state.setStateAtTime(\"stopped\", ticks);\n\t\tthis._forEach(event => {\n\t\t\tevent.stop(time);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get/Set an Event's value at the given time.\n\t * If a value is passed in and no event exists at\n\t * the given time, one will be created with that value.\n\t * If two events are at the same time, the first one will\n\t * be returned.\n\t * @example\n\t * const part = new Tone.Part();\n\t * part.at(\"1m\"); // returns the part at the first measure\n\t * part.at(\"2m\", \"C2\"); // set the value at \"2m\" to C2.\n\t * // if an event didn't exist at that time, it will be created.\n\t * @param time The time of the event to get or set.\n\t * @param value If a value is passed in, the value of the event at the given time will be set to it.\n\t */\n\tat(time: Time, value?: any): ToneEvent | null {\n\t\tconst timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n\t\tconst tickTime = new TicksClass(this.context, 1).toSeconds();\n\n\t\tconst iterator = this._events.values();\n\t\tlet result = iterator.next();\n\t\twhile (!result.done) {\n\t\t\tconst event = result.value;\n\t\t\tif (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n\t\t\t\tif (isDefined(value)) {\n\t\t\t\t\tevent.value = value;\n\t\t\t\t}\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tresult = iterator.next();\n\t\t}\n\t\t// if there was no event at that time, create one\n\t\tif (isDefined(value)) {\n\t\t\tthis.add(time, value);\n\t\t\t// return the new event\n\t\t\treturn this.at(time);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Add a an event to the part.\n\t * @param time The time the note should start. If an object is passed in, it should\n\t * \t\thave a 'time' attribute and the rest of the object will be used as the 'value'.\n\t * @param  value\n\t * @example\n\t * const part = new Tone.Part();\n\t * part.add(\"1m\", \"C#+11\");\n\t */\n\tadd(obj: {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t}): this;\n\tadd(time: Time, value?: any): this;\n\tadd(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (time instanceof Object && Reflect.has(time, \"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\tconst ticks = this.toTicks(time);\n\t\tlet event: ToneEvent;\n\t\tif (value instanceof ToneEvent) {\n\t\t\tevent = value;\n\t\t\tevent.callback = this._tick.bind(this);\n\t\t} else {\n\t\t\tevent = new ToneEvent({\n\t\t\t\tcallback: this._tick.bind(this),\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue,\n\t\t\t});\n\t\t}\n\t\t// the start offset\n\t\tevent.startOffset = ticks;\n\n\t\t// initialize the values\n\t\tevent.set({\n\t\t\thumanize: this.humanize,\n\t\t\tloop: this.loop,\n\t\t\tloopEnd: this.loopEnd,\n\t\t\tloopStart: this.loopStart,\n\t\t\tplaybackRate: this.playbackRate,\n\t\t\tprobability: this.probability,\n\t\t});\n\n\t\tthis._events.add(event);\n\n\t\t// start the note if it should be played right now\n\t\tthis._restartEvent(event);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the given event\n\t */\n\tprivate _restartEvent(event: ToneEvent): void {\n\t\tthis._state.forEach((stateEvent) => {\n\t\t\tif (stateEvent.state === \"started\") {\n\t\t\t\tthis._startNote(event, stateEvent.time, stateEvent.offset);\n\t\t\t} else {\n\t\t\t\t// stop the note\n\t\t\t\tevent.stop(new TicksClass(this.context, stateEvent.time));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Remove an event from the part. If the event at that time is a Part,\n\t * it will remove the entire part.\n\t * @param time The time of the event\n\t * @param value Optionally select only a specific event value\n\t */\n\tremove(obj: {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t}): this;\n\tremove(time: Time, value?: any): this;\n\tremove(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (isObject(time) && time.hasOwnProperty(\"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\ttime = this.toTicks(time);\n\t\tthis._events.forEach(event => {\n\t\t\tif (event.startOffset === time) {\n\t\t\t\tif (isUndef(value) || (isDefined(value) && event.value === value)) {\n\t\t\t\t\tthis._events.delete(event);\n\t\t\t\t\tevent.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove all of the notes from the group.\n\t */\n\tclear(): this {\n\t\tthis._forEach(event => event.dispose());\n\t\tthis._events.clear();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n\t * @param after The time after which to cancel the scheduled events.\n\t */\n\tcancel(after?: TransportTime | TransportTimeClass): this {\n\t\tthis._forEach(event => event.cancel(after));\n\t\tthis._state.cancel(this.toTicks(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over all of the events\n\t */\n\tprivate _forEach(callback: (event: ToneEvent) => void): this {\n\t\tif (this._events) {\n\t\t\tthis._events.forEach(event => {\n\t\t\t\tif (event instanceof Part) {\n\t\t\t\t\tevent._forEach(callback);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the attribute of all of the events\n\t * @param  attr  the attribute to set\n\t * @param  value      The value to set it to\n\t */\n\tprivate _setAll(attr: string, value: any): void {\n\t\tthis._forEach(event => {\n\t\t\tevent[attr] = value;\n\t\t});\n\t}\n\n\t/**\n\t * Internal tick method\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds, value?: any): void {\n\t\tif (!this.mute) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the event should be currently looping\n\t * given the loop boundries of this Part.\n\t * @param  event  The event to test\n\t */\n\tprivate _testLoopBoundries(event: ToneEvent): void {\n\t\tif (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n\t\t\tevent.cancel(0);\n\t\t} else if (event.state === \"stopped\") {\n\t\t\t// reschedule it if it's stopped\n\t\t\tthis._restartEvent(event);\n\t\t}\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t\tthis._setAll(\"probability\", prob);\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t\tthis._setAll(\"humanize\", variation);\n\t}\n\n\t/**\n\t * If the part should loop or not\n\t * between Part.loopStart and\n\t * Part.loopEnd. If set to true,\n\t * the part will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t * @example\n\t * const part = new Tone.Part();\n\t * // loop the part 8 times\n\t * part.loop = 8;\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._forEach(event => {\n\t\t\tevent.loopStart = this.loopStart;\n\t\t\tevent.loopEnd = this.loopEnd;\n\t\t\tevent.loop = loop;\n\t\t\tthis._testLoopBoundries(event);\n\t\t});\n\t}\n\n\t/**\n\t * The loopEnd point determines when it will\n\t * loop if Part.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopEnd = loopEnd;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The loopStart point determines when it will\n\t * loop if Part.loop is true.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopStart = this.loopStart;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The playback rate of the part\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._setAll(\"playbackRate\", rate);\n\t}\n\n\t/**\n\t * The number of scheduled notes in the part.\n\t */\n\tget length(): number {\n\t\treturn this._events.size;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.clear();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}