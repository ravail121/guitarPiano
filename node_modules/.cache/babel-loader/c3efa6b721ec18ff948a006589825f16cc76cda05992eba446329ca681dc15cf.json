{"ast":null,"code":"// src/utils.ts\nvar fillStr = (s, n) => Array(Math.abs(n) + 1).join(s);\nfunction deprecate(original, alternative, fn) {\n  return function () {\n    console.warn(`${original} is deprecated. Use ${alternative}.`);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return fn.apply(this, args);\n  };\n}\n\n// src/named.ts\nfunction isNamed(src) {\n  return src !== null && typeof src === \"object\" && typeof src.name === \"string\" ? true : false;\n}\n\n// src/pitch.ts\nfunction isPitch(pitch) {\n  return pitch !== null && typeof pitch === \"object\" && typeof pitch.step === \"number\" && typeof pitch.alt === \"number\" ? true : false;\n}\nvar FIFTHS = [0, 2, 4, -1, 1, 3, 5];\nvar STEPS_TO_OCTS = FIFTHS.map(fifths => Math.floor(fifths * 7 / 12));\nfunction encode(pitch) {\n  const {\n    step,\n    alt,\n    oct,\n    dir = 1\n  } = pitch;\n  const f = FIFTHS[step] + 7 * alt;\n  if (oct === void 0) {\n    return [dir * f];\n  }\n  const o = oct - STEPS_TO_OCTS[step] - 4 * alt;\n  return [dir * f, dir * o];\n}\nvar FIFTHS_TO_STEPS = [3, 0, 4, 1, 5, 2, 6];\nfunction decode(coord) {\n  const [f, o, dir] = coord;\n  const step = FIFTHS_TO_STEPS[unaltered(f)];\n  const alt = Math.floor((f + 1) / 7);\n  if (o === void 0) {\n    return {\n      step,\n      alt,\n      dir\n    };\n  }\n  const oct = o + 4 * alt + STEPS_TO_OCTS[step];\n  return {\n    step,\n    alt,\n    oct,\n    dir\n  };\n}\nfunction unaltered(f) {\n  const i = (f + 1) % 7;\n  return i < 0 ? 7 + i : i;\n}\n\n// src/note.ts\nvar NoNote = {\n  empty: true,\n  name: \"\",\n  pc: \"\",\n  acc: \"\"\n};\nvar cache = /* @__PURE__ */new Map();\nvar stepToLetter = step => \"CDEFGAB\".charAt(step);\nvar altToAcc = alt => alt < 0 ? fillStr(\"b\", -alt) : fillStr(\"#\", alt);\nvar accToAlt = acc => acc[0] === \"b\" ? -acc.length : acc.length;\nfunction note(src) {\n  const stringSrc = JSON.stringify(src);\n  const cached = cache.get(stringSrc);\n  if (cached) {\n    return cached;\n  }\n  const value = typeof src === \"string\" ? parse(src) : isPitch(src) ? note(pitchName(src)) : isNamed(src) ? note(src.name) : NoNote;\n  cache.set(stringSrc, value);\n  return value;\n}\nvar REGEX = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)$/;\nfunction tokenizeNote(str) {\n  const m = REGEX.exec(str);\n  return [m[1].toUpperCase(), m[2].replace(/x/g, \"##\"), m[3], m[4]];\n}\nfunction coordToNote(noteCoord) {\n  return note(decode(noteCoord));\n}\nvar mod = (n, m) => (n % m + m) % m;\nvar SEMI = [0, 2, 4, 5, 7, 9, 11];\nfunction parse(noteName) {\n  const tokens = tokenizeNote(noteName);\n  if (tokens[0] === \"\" || tokens[3] !== \"\") {\n    return NoNote;\n  }\n  const letter = tokens[0];\n  const acc = tokens[1];\n  const octStr = tokens[2];\n  const step = (letter.charCodeAt(0) + 3) % 7;\n  const alt = accToAlt(acc);\n  const oct = octStr.length ? +octStr : void 0;\n  const coord = encode({\n    step,\n    alt,\n    oct\n  });\n  const name = letter + acc + octStr;\n  const pc = letter + acc;\n  const chroma = (SEMI[step] + alt + 120) % 12;\n  const height = oct === void 0 ? mod(SEMI[step] + alt, 12) - 12 * 99 : SEMI[step] + alt + 12 * (oct + 1);\n  const midi = height >= 0 && height <= 127 ? height : null;\n  const freq = oct === void 0 ? null : Math.pow(2, (height - 69) / 12) * 440;\n  return {\n    empty: false,\n    acc,\n    alt,\n    chroma,\n    coord,\n    freq,\n    height,\n    letter,\n    midi,\n    name,\n    oct,\n    pc,\n    step\n  };\n}\nfunction pitchName(props) {\n  const {\n    step,\n    alt,\n    oct\n  } = props;\n  const letter = stepToLetter(step);\n  if (!letter) {\n    return \"\";\n  }\n  const pc = letter + altToAcc(alt);\n  return oct || oct === 0 ? pc + oct : pc;\n}\n\n// src/interval.ts\nvar NoInterval = {\n  empty: true,\n  name: \"\",\n  acc: \"\"\n};\nvar INTERVAL_TONAL_REGEX = \"([-+]?\\\\d+)(d{1,4}|m|M|P|A{1,4})\";\nvar INTERVAL_SHORTHAND_REGEX = \"(AA|A|P|M|m|d|dd)([-+]?\\\\d+)\";\nvar REGEX2 = new RegExp(\"^\" + INTERVAL_TONAL_REGEX + \"|\" + INTERVAL_SHORTHAND_REGEX + \"$\");\nfunction tokenizeInterval(str) {\n  const m = REGEX2.exec(`${str}`);\n  if (m === null) {\n    return [\"\", \"\"];\n  }\n  return m[1] ? [m[1], m[2]] : [m[4], m[3]];\n}\nvar cache2 = {};\nfunction interval(src) {\n  return typeof src === \"string\" ? cache2[src] || (cache2[src] = parse2(src)) : isPitch(src) ? interval(pitchName2(src)) : isNamed(src) ? interval(src.name) : NoInterval;\n}\nvar SIZES = [0, 2, 4, 5, 7, 9, 11];\nvar TYPES = \"PMMPPMM\";\nfunction parse2(str) {\n  const tokens = tokenizeInterval(str);\n  if (tokens[0] === \"\") {\n    return NoInterval;\n  }\n  const num = +tokens[0];\n  const q = tokens[1];\n  const step = (Math.abs(num) - 1) % 7;\n  const t = TYPES[step];\n  if (t === \"M\" && q === \"P\") {\n    return NoInterval;\n  }\n  const type = t === \"M\" ? \"majorable\" : \"perfectable\";\n  const name = \"\" + num + q;\n  const dir = num < 0 ? -1 : 1;\n  const simple = num === 8 || num === -8 ? num : dir * (step + 1);\n  const alt = qToAlt(type, q);\n  const oct = Math.floor((Math.abs(num) - 1) / 7);\n  const semitones = dir * (SIZES[step] + alt + 12 * oct);\n  const chroma = (dir * (SIZES[step] + alt) % 12 + 12) % 12;\n  const coord = encode({\n    step,\n    alt,\n    oct,\n    dir\n  });\n  return {\n    empty: false,\n    name,\n    num,\n    q,\n    step,\n    alt,\n    dir,\n    type,\n    simple,\n    semitones,\n    chroma,\n    coord,\n    oct\n  };\n}\nfunction coordToInterval(coord, forceDescending) {\n  const [f, o = 0] = coord;\n  const isDescending = f * 7 + o * 12 < 0;\n  const ivl = forceDescending || isDescending ? [-f, -o, -1] : [f, o, 1];\n  return interval(decode(ivl));\n}\nfunction qToAlt(type, q) {\n  return q === \"M\" && type === \"majorable\" || q === \"P\" && type === \"perfectable\" ? 0 : q === \"m\" && type === \"majorable\" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === \"perfectable\" ? q.length : q.length + 1) : 0;\n}\nfunction pitchName2(props) {\n  const {\n    step,\n    alt,\n    oct = 0,\n    dir\n  } = props;\n  if (!dir) {\n    return \"\";\n  }\n  const calcNum = step + 1 + 7 * oct;\n  const num = calcNum === 0 ? step + 1 : calcNum;\n  const d = dir < 0 ? \"-\" : \"\";\n  const type = TYPES[step] === \"M\" ? \"majorable\" : \"perfectable\";\n  const name = d + num + altToQ(type, alt);\n  return name;\n}\nfunction altToQ(type, alt) {\n  if (alt === 0) {\n    return type === \"majorable\" ? \"M\" : \"P\";\n  } else if (alt === -1 && type === \"majorable\") {\n    return \"m\";\n  } else if (alt > 0) {\n    return fillStr(\"A\", alt);\n  } else {\n    return fillStr(\"d\", type === \"perfectable\" ? alt : alt + 1);\n  }\n}\n\n// src/distance.ts\nfunction transpose(noteName, intervalName) {\n  const note2 = note(noteName);\n  const intervalCoord = Array.isArray(intervalName) ? intervalName : interval(intervalName).coord;\n  if (note2.empty || !intervalCoord || intervalCoord.length < 2) {\n    return \"\";\n  }\n  const noteCoord = note2.coord;\n  const tr = noteCoord.length === 1 ? [noteCoord[0] + intervalCoord[0]] : [noteCoord[0] + intervalCoord[0], noteCoord[1] + intervalCoord[1]];\n  return coordToNote(tr).name;\n}\nfunction tonicIntervalsTransposer(intervals, tonic) {\n  const len = intervals.length;\n  return normalized => {\n    if (!tonic) return \"\";\n    const index = normalized < 0 ? (len - -normalized % len) % len : normalized % len;\n    const octaves = Math.floor(normalized / len);\n    const root = transpose(tonic, [0, octaves]);\n    return transpose(root, intervals[index]);\n  };\n}\nfunction distance(fromNote, toNote) {\n  const from = note(fromNote);\n  const to = note(toNote);\n  if (from.empty || to.empty) {\n    return \"\";\n  }\n  const fcoord = from.coord;\n  const tcoord = to.coord;\n  const fifths = tcoord[0] - fcoord[0];\n  const octs = fcoord.length === 2 && tcoord.length === 2 ? tcoord[1] - fcoord[1] : -Math.floor(fifths * 7 / 12);\n  const forceDescending = to.height === from.height && to.midi !== null && from.midi !== null && from.step > to.step;\n  return coordToInterval([fifths, octs], forceDescending).name;\n}\nexport { accToAlt, altToAcc, coordToInterval, coordToNote, decode, deprecate, distance, encode, fillStr, interval, isNamed, isPitch, note, stepToLetter, tokenizeInterval, tokenizeNote, tonicIntervalsTransposer, transpose };","map":{"version":3,"mappings":"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","names":["fillStr","s","n","Array","Math","abs","join","deprecate","original","alternative","fn","console","warn","args","apply","isNamed","src","name","isPitch","pitch","step","alt","FIFTHS","STEPS_TO_OCTS","map","fifths","floor","encode","oct","dir","f","o","FIFTHS_TO_STEPS","decode","coord","unaltered","i","NoNote","empty","pc","acc","cache","Map","stepToLetter","charAt","altToAcc","accToAlt","length","note","stringSrc","JSON","stringify","cached","get","value","parse","pitchName","set","REGEX","tokenizeNote","str","m","exec","toUpperCase","replace","coordToNote","noteCoord","mod","SEMI","noteName","tokens","letter","octStr","charCodeAt","chroma","height","midi","freq","pow","props","NoInterval","INTERVAL_TONAL_REGEX","INTERVAL_SHORTHAND_REGEX","RegExp","tokenizeInterval","interval","SIZES","TYPES","num","q","t","type","simple","qToAlt","semitones","coordToInterval","forceDescending","isDescending","ivl","test","calcNum","d","altToQ","transpose","intervalName","intervalCoord","isArray","tr","tonicIntervalsTransposer","intervals","tonic","len","normalized","index","octaves","root","distance","fromNote","toNote","from","to","fcoord","tcoord","octs"],"sources":["/Users/macbook/Desktop/Music/OwnGuitar/node_modules/@tonaljs/core/src/utils.ts","/Users/macbook/Desktop/Music/OwnGuitar/node_modules/@tonaljs/core/src/named.ts","/Users/macbook/Desktop/Music/OwnGuitar/node_modules/@tonaljs/core/src/pitch.ts","/Users/macbook/Desktop/Music/OwnGuitar/node_modules/@tonaljs/core/src/note.ts","/Users/macbook/Desktop/Music/OwnGuitar/node_modules/@tonaljs/core/src/interval.ts","/Users/macbook/Desktop/Music/OwnGuitar/node_modules/@tonaljs/core/src/distance.ts"],"sourcesContent":["/**\n * Fill a string with a repeated character\n *\n * @param character\n * @param repetition\n */\nexport const fillStr = (s: string, n: number) => Array(Math.abs(n) + 1).join(s);\n\nexport function deprecate<\n  ResultFn extends (this: any, ...newArgs: any[]) => ReturnType<ResultFn>\n>(original: string, alternative: string, fn: ResultFn) {\n  return function (this: unknown, ...args: unknown[]): ReturnType<ResultFn> {\n    // tslint:disable-next-line\n    console.warn(`${original} is deprecated. Use ${alternative}.`);\n    return fn.apply(this, args);\n  };\n}\n","export interface Named {\n  readonly name: string;\n}\n\nexport interface NamedFound {\n  readonly empty: false;\n}\n\nexport interface NotFound extends Named {\n  readonly empty: true;\n  readonly name: \"\";\n}\n\nexport function isNamed(src: any): src is Named {\n  return src !== null && typeof src === \"object\" && typeof src.name === \"string\"\n    ? true\n    : false;\n}\n","import { Named } from \"./named\";\n\ntype Fifths = number;\ntype Octaves = number;\nexport type Direction = 1 | -1;\n\nexport type PitchClassCoordinates = [Fifths];\nexport type NoteCoordinates = [Fifths, Octaves];\nexport type IntervalCoordinates = [Fifths, Octaves, Direction];\nexport type PitchCoordinates =\n  | PitchClassCoordinates\n  | NoteCoordinates\n  | IntervalCoordinates;\n\n/**\n * Pitch properties\n *\n * - {number} step - The step number: 0 = C, 1 = D, ... 6 = B\n * - {number} alt - Number of alterations: -2 = 'bb', -1 = 'b', 0 = '', 1 = '#', ...\n * - {number} [oct] = The octave (undefined when is a coord class)\n * - {number} [dir] = Interval direction (undefined when is not an interval)\n */\nexport interface Pitch {\n  readonly step: number;\n  readonly alt: number;\n  readonly oct?: number; // undefined for pitch classes\n  readonly dir?: Direction; // undefined for notes\n}\n\nexport function isPitch(pitch: any): pitch is Pitch {\n  return pitch !== null &&\n    typeof pitch === \"object\" &&\n    typeof pitch.step === \"number\" &&\n    typeof pitch.alt === \"number\"\n    ? true\n    : false;\n}\n\n// The number of fifths of [C, D, E, F, G, A, B]\nconst FIFTHS = [0, 2, 4, -1, 1, 3, 5];\n// The number of octaves it span each step\nconst STEPS_TO_OCTS = FIFTHS.map((fifths: number) =>\n  Math.floor((fifths * 7) / 12)\n);\n\nexport function encode(pitch: Pitch): PitchCoordinates {\n  const { step, alt, oct, dir = 1 } = pitch;\n  const f = FIFTHS[step] + 7 * alt;\n  if (oct === undefined) {\n    return [dir * f];\n  }\n  const o = oct - STEPS_TO_OCTS[step] - 4 * alt;\n  return [dir * f, dir * o];\n}\n\n// We need to get the steps from fifths\n// Fifths for CDEFGAB are [ 0, 2, 4, -1, 1, 3, 5 ]\n// We add 1 to fifths to avoid negative numbers, so:\n// for [\"F\", \"C\", \"G\", \"D\", \"A\", \"E\", \"B\"] we have:\nconst FIFTHS_TO_STEPS = [3, 0, 4, 1, 5, 2, 6];\n\nexport function decode(coord: PitchCoordinates): Pitch {\n  const [f, o, dir] = coord;\n  const step = FIFTHS_TO_STEPS[unaltered(f)];\n  const alt = Math.floor((f + 1) / 7);\n  if (o === undefined) {\n    return { step, alt, dir };\n  }\n  const oct = o + 4 * alt + STEPS_TO_OCTS[step];\n  return { step, alt, oct, dir };\n}\n\n// Return the number of fifths as if it were unaltered\nfunction unaltered(f: number): number {\n  const i = (f + 1) % 7;\n  return i < 0 ? 7 + i : i;\n}\n","import { isNamed, Named } from \"./named\";\nimport { decode, encode, isPitch, Pitch, PitchCoordinates } from \"./pitch\";\nimport { fillStr } from \"./utils\";\n\nexport type NoteWithOctave = string;\nexport type PcName = string;\nexport type NoteName = NoteWithOctave | PcName;\nexport type NoteLiteral = NoteName | Pitch | Named;\n\nexport interface Note extends Pitch, Named {\n  readonly empty: boolean;\n  readonly name: NoteName;\n  readonly letter: string;\n  readonly acc: string;\n  readonly pc: PcName;\n  readonly chroma: number;\n  readonly height: number;\n  readonly coord: PitchCoordinates;\n  readonly midi: number | null;\n  readonly freq: number | null;\n}\n\nexport interface NoNote extends Partial<Note> {\n  empty: true;\n  name: \"\";\n  pc: \"\";\n  acc: \"\";\n}\nconst NoNote: NoNote = { empty: true, name: \"\", pc: \"\", acc: \"\" };\n\nconst cache: Map<NoteLiteral | undefined, Note | NoNote> = new Map();\n\nexport const stepToLetter = (step: number) => \"CDEFGAB\".charAt(step);\nexport const altToAcc = (alt: number): string =>\n  alt < 0 ? fillStr(\"b\", -alt) : fillStr(\"#\", alt);\nexport const accToAlt = (acc: string): number =>\n  acc[0] === \"b\" ? -acc.length : acc.length;\n\n/**\n * Given a note literal (a note name or a note object), returns the Note object\n * @example\n * note('Bb4') // => { name: \"Bb4\", midi: 70, chroma: 10, ... }\n */\nexport function note(src: NoteLiteral): Note | NoNote {\n  const stringSrc = JSON.stringify(src);\n\n  const cached = cache.get(stringSrc);\n  if (cached) {\n    return cached;\n  }\n\n  const value =\n    typeof src === \"string\"\n      ? parse(src)\n      : isPitch(src)\n      ? note(pitchName(src))\n      : isNamed(src)\n      ? note(src.name)\n      : NoNote;\n  cache.set(stringSrc, value);\n  return value;\n}\n\ntype NoteTokens = [string, string, string, string];\n\nconst REGEX = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)$/;\n\n/**\n * @private\n */\nexport function tokenizeNote(str: string): NoteTokens {\n  const m = REGEX.exec(str) as string[];\n  return [m[1].toUpperCase(), m[2].replace(/x/g, \"##\"), m[3], m[4]];\n}\n\n/**\n * @private\n */\nexport function coordToNote(noteCoord: PitchCoordinates): Note {\n  return note(decode(noteCoord)) as Note;\n}\n\nconst mod = (n: number, m: number) => ((n % m) + m) % m;\n\nconst SEMI = [0, 2, 4, 5, 7, 9, 11];\nfunction parse(noteName: NoteName): Note | NoNote {\n  const tokens = tokenizeNote(noteName);\n  if (tokens[0] === \"\" || tokens[3] !== \"\") {\n    return NoNote;\n  }\n\n  const letter = tokens[0];\n  const acc = tokens[1];\n  const octStr = tokens[2];\n\n  const step = (letter.charCodeAt(0) + 3) % 7;\n  const alt = accToAlt(acc);\n  const oct = octStr.length ? +octStr : undefined;\n  const coord = encode({ step, alt, oct });\n\n  const name = letter + acc + octStr;\n  const pc = letter + acc;\n  const chroma = (SEMI[step] + alt + 120) % 12;\n  const height =\n    oct === undefined\n      ? mod(SEMI[step] + alt, 12) - 12 * 99\n      : SEMI[step] + alt + 12 * (oct + 1);\n  const midi = height >= 0 && height <= 127 ? height : null;\n  const freq = oct === undefined ? null : Math.pow(2, (height - 69) / 12) * 440;\n\n  return {\n    empty: false,\n    acc,\n    alt,\n    chroma,\n    coord,\n    freq,\n    height,\n    letter,\n    midi,\n    name,\n    oct,\n    pc,\n    step,\n  };\n}\n\nfunction pitchName(props: Pitch): NoteName {\n  const { step, alt, oct } = props;\n  const letter = stepToLetter(step);\n  if (!letter) {\n    return \"\";\n  }\n\n  const pc = letter + altToAcc(alt);\n  return oct || oct === 0 ? pc + oct : pc;\n}\n","import { isNamed, Named } from \"./named\";\nimport {\n  decode,\n  Direction,\n  encode,\n  IntervalCoordinates,\n  isPitch,\n  Pitch,\n  PitchCoordinates,\n} from \"./pitch\";\nimport { fillStr } from \"./utils\";\n\nexport type IntervalName = string;\nexport type IntervalLiteral = IntervalName | Pitch | Named;\n\ntype Quality =\n  | \"dddd\"\n  | \"ddd\"\n  | \"dd\"\n  | \"d\"\n  | \"m\"\n  | \"M\"\n  | \"P\"\n  | \"A\"\n  | \"AA\"\n  | \"AAA\"\n  | \"AAAA\";\ntype Type = \"perfectable\" | \"majorable\";\n\nexport interface Interval extends Pitch, Named {\n  readonly empty: boolean;\n  readonly name: IntervalName;\n  readonly num: number;\n  readonly q: Quality;\n  readonly type: Type;\n  readonly step: number;\n  readonly alt: number;\n  readonly dir: Direction;\n  readonly simple: number;\n  readonly semitones: number;\n  readonly chroma: number;\n  readonly coord: IntervalCoordinates;\n  readonly oct: number;\n}\n\nexport interface NoInterval extends Partial<Interval> {\n  readonly empty: true;\n  readonly name: \"\";\n  readonly acc: \"\";\n}\n\nconst NoInterval: NoInterval = { empty: true, name: \"\", acc: \"\" };\n\n// shorthand tonal notation (with quality after number)\nconst INTERVAL_TONAL_REGEX = \"([-+]?\\\\d+)(d{1,4}|m|M|P|A{1,4})\";\n// standard shorthand notation (with quality before number)\nconst INTERVAL_SHORTHAND_REGEX = \"(AA|A|P|M|m|d|dd)([-+]?\\\\d+)\";\nconst REGEX = new RegExp(\n  \"^\" + INTERVAL_TONAL_REGEX + \"|\" + INTERVAL_SHORTHAND_REGEX + \"$\"\n);\n\ntype IntervalTokens = [string, string];\n\n/**\n * @private\n */\nexport function tokenizeInterval(str?: IntervalName): IntervalTokens {\n  const m = REGEX.exec(`${str}`);\n  if (m === null) {\n    return [\"\", \"\"];\n  }\n  return m[1] ? [m[1], m[2]] : [m[4], m[3]];\n}\n\nconst cache: { [key in string]: Interval | NoInterval } = {};\n\n/**\n * Get interval properties. It returns an object with:\n *\n * - name: the interval name\n * - num: the interval number\n * - type: 'perfectable' or 'majorable'\n * - q: the interval quality (d, m, M, A)\n * - dir: interval direction (1 ascending, -1 descending)\n * - simple: the simplified number\n * - semitones: the size in semitones\n * - chroma: the interval chroma\n *\n * @param {string} interval - the interval name\n * @return {Object} the interval properties\n *\n * @example\n * import { interval } from '@tonaljs/core'\n * interval('P5').semitones // => 7\n * interval('m3').type // => 'majorable'\n */\nexport function interval(src: IntervalLiteral): Interval | NoInterval {\n  return typeof src === \"string\"\n    ? cache[src] || (cache[src] = parse(src))\n    : isPitch(src)\n    ? interval(pitchName(src))\n    : isNamed(src)\n    ? interval(src.name)\n    : NoInterval;\n}\n\nconst SIZES = [0, 2, 4, 5, 7, 9, 11];\nconst TYPES = \"PMMPPMM\";\nfunction parse(str?: string): Interval | NoInterval {\n  const tokens = tokenizeInterval(str);\n  if (tokens[0] === \"\") {\n    return NoInterval;\n  }\n  const num = +tokens[0];\n  const q = tokens[1] as Quality;\n  const step = (Math.abs(num) - 1) % 7;\n  const t = TYPES[step];\n  if (t === \"M\" && q === \"P\") {\n    return NoInterval;\n  }\n  const type = t === \"M\" ? \"majorable\" : \"perfectable\";\n\n  const name = \"\" + num + q;\n  const dir = num < 0 ? -1 : 1;\n  const simple = num === 8 || num === -8 ? num : dir * (step + 1);\n  const alt = qToAlt(type, q);\n  const oct = Math.floor((Math.abs(num) - 1) / 7);\n  const semitones = dir * (SIZES[step] + alt + 12 * oct);\n  const chroma = (((dir * (SIZES[step] + alt)) % 12) + 12) % 12;\n  const coord = encode({ step, alt, oct, dir }) as IntervalCoordinates;\n  return {\n    empty: false,\n    name,\n    num,\n    q,\n    step,\n    alt,\n    dir,\n    type,\n    simple,\n    semitones,\n    chroma,\n    coord,\n    oct,\n  };\n}\n\n/**\n * @private\n *\n * forceDescending is used in the case of unison (#243)\n */\nexport function coordToInterval(\n  coord: PitchCoordinates,\n  forceDescending?: boolean\n): Interval {\n  const [f, o = 0] = coord;\n  const isDescending = f * 7 + o * 12 < 0;\n  const ivl: IntervalCoordinates =\n    forceDescending || isDescending ? [-f, -o, -1] : [f, o, 1];\n  return interval(decode(ivl)) as Interval;\n}\n\nfunction qToAlt(type: Type, q: string): number {\n  return (q === \"M\" && type === \"majorable\") ||\n    (q === \"P\" && type === \"perfectable\")\n    ? 0\n    : q === \"m\" && type === \"majorable\"\n    ? -1\n    : /^A+$/.test(q)\n    ? q.length\n    : /^d+$/.test(q)\n    ? -1 * (type === \"perfectable\" ? q.length : q.length + 1)\n    : 0;\n}\n\n// return the interval name of a pitch\nfunction pitchName(props: Pitch): string {\n  const { step, alt, oct = 0, dir } = props;\n  if (!dir) {\n    return \"\";\n  }\n  const calcNum = step + 1 + 7 * oct;\n  // this is an edge case: descending pitch class unison (see #243)\n  const num = calcNum === 0 ? step + 1 : calcNum;\n  const d = dir < 0 ? \"-\" : \"\";\n  const type = TYPES[step] === \"M\" ? \"majorable\" : \"perfectable\";\n  const name = d + num + altToQ(type, alt);\n  return name;\n}\n\nfunction altToQ(type: Type, alt: number): Quality {\n  if (alt === 0) {\n    return type === \"majorable\" ? \"M\" : \"P\";\n  } else if (alt === -1 && type === \"majorable\") {\n    return \"m\";\n  } else if (alt > 0) {\n    return fillStr(\"A\", alt) as Quality;\n  } else {\n    return fillStr(\"d\", type === \"perfectable\" ? alt : alt + 1) as Quality;\n  }\n}\n","import {\n  coordToInterval,\n  interval as asInterval,\n  IntervalLiteral,\n  IntervalName,\n} from \"./interval\";\nimport { coordToNote, note as asNote, NoteLiteral, NoteName } from \"./note\";\nimport { PitchCoordinates } from \"./pitch\";\n\n/**\n * Transpose a note by an interval.\n *\n * @param {string} note - the note or note name\n * @param {string} interval - the interval or interval name\n * @return {string} the transposed note name or empty string if not valid notes\n * @example\n * import { tranpose } from \"@tonaljs/core\"\n * transpose(\"d3\", \"3M\") // => \"F#3\"\n * transpose(\"D\", \"3M\") // => \"F#\"\n * [\"C\", \"D\", \"E\", \"F\", \"G\"].map(pc => transpose(pc, \"M3)) // => [\"E\", \"F#\", \"G#\", \"A\", \"B\"]\n */\nexport function transpose(\n  noteName: NoteLiteral,\n  intervalName: IntervalLiteral | [number, number]\n): NoteName {\n  const note = asNote(noteName);\n  const intervalCoord = Array.isArray(intervalName)\n    ? intervalName\n    : asInterval(intervalName).coord;\n  if (note.empty || !intervalCoord || intervalCoord.length < 2) {\n    return \"\";\n  }\n  const noteCoord = note.coord;\n  const tr: PitchCoordinates =\n    noteCoord.length === 1\n      ? [noteCoord[0] + intervalCoord[0]]\n      : [noteCoord[0] + intervalCoord[0], noteCoord[1] + intervalCoord[1]];\n  return coordToNote(tr).name;\n}\n\n// Private\nexport function tonicIntervalsTransposer(\n  intervals: string[],\n  tonic: string | undefined | null\n) {\n  const len = intervals.length;\n  return (normalized: number) => {\n    if (!tonic) return \"\";\n    const index =\n      normalized < 0 ? (len - (-normalized % len)) % len : normalized % len;\n    const octaves = Math.floor(normalized / len);\n    const root = transpose(tonic, [0, octaves]);\n    return transpose(root, intervals[index]);\n  };\n}\n\n/**\n * Find the interval distance between two notes or coord classes.\n *\n * To find distance between coord classes, both notes must be coord classes and\n * the interval is always ascending\n *\n * @param {Note|string} from - the note or note name to calculate distance from\n * @param {Note|string} to - the note or note name to calculate distance to\n * @return {string} the interval name or empty string if not valid notes\n *\n */\nexport function distance(\n  fromNote: NoteLiteral,\n  toNote: NoteLiteral\n): IntervalName {\n  const from = asNote(fromNote);\n  const to = asNote(toNote);\n  if (from.empty || to.empty) {\n    return \"\";\n  }\n\n  const fcoord = from.coord;\n  const tcoord = to.coord;\n  const fifths = tcoord[0] - fcoord[0];\n  const octs =\n    fcoord.length === 2 && tcoord.length === 2\n      ? tcoord[1] - fcoord[1]\n      : -Math.floor((fifths * 7) / 12);\n\n  // If it's unison and not pitch class, it can be descending interval (#243)\n  const forceDescending =\n    to.height === from.height &&\n    to.midi !== null &&\n    from.midi !== null &&\n    from.step > to.step;\n  return coordToInterval([fifths, octs], forceDescending).name;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}