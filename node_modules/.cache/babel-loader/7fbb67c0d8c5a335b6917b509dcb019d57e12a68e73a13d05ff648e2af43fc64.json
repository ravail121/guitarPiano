{"ast":null,"code":"'use strict';\n\nvar base64 = require('./base64');\nvar fetch = require('./fetch');\n\n// Given a regex, return a function that test if against a string\nfunction fromRegex(r) {\n  return function (o) {\n    return typeof o === 'string' && r.test(o);\n  };\n}\n// Try to apply a prefix to a name\nfunction prefix(pre, name) {\n  return typeof pre === 'string' ? pre + name : typeof pre === 'function' ? pre(name) : name;\n}\n\n/**\n * Load one or more audio files\n *\n *\n * Possible option keys:\n *\n * - __from__ {Function|String}: a function or string to convert from file names to urls.\n * If is a string it will be prefixed to the name:\n * `load(ac, 'snare.mp3', { from: 'http://audio.net/samples/' })`\n * If it's a function it receives the file name and should return the url as string.\n * - __only__ {Array} - when loading objects, if provided, only the given keys\n * will be included in the decoded object:\n * `load(ac, 'piano.json', { only: ['C2', 'D2'] })`\n *\n * @param {AudioContext} ac - the audio context\n * @param {Object} source - the object to be loaded\n * @param {Object} options - (Optional) the load options for that object\n * @param {Object} defaultValue - (Optional) the default value to return as\n * in a promise if not valid loader found\n */\nfunction load(ac, source, options, defVal) {\n  var loader =\n  // Basic audio loading\n  isArrayBuffer(source) ? loadArrayBuffer : isAudioFileName(source) ? loadAudioFile : isPromise(source) ? loadPromise\n  // Compound objects\n  : isArray(source) ? loadArrayData : isObject(source) ? loadObjectData : isJsonFileName(source) ? loadJsonFile\n  // Base64 encoded audio\n  : isBase64Audio(source) ? loadBase64Audio : isJsFileName(source) ? loadMidiJSFile : null;\n  var opts = options || {};\n  return loader ? loader(ac, source, opts) : defVal ? Promise.resolve(defVal) : Promise.reject('Source not valid (' + source + ')');\n}\nload.fetch = fetch;\n\n// BASIC AUDIO LOADING\n// ===================\n\n// Load (decode) an array buffer\nfunction isArrayBuffer(o) {\n  return o instanceof ArrayBuffer;\n}\nfunction loadArrayBuffer(ac, array, options) {\n  return new Promise(function (done, reject) {\n    ac.decodeAudioData(array, function (buffer) {\n      done(buffer);\n    }, function () {\n      reject(\"Can't decode audio data (\" + array.slice(0, 30) + '...)');\n    });\n  });\n}\n\n// Load an audio filename\nvar isAudioFileName = fromRegex(/\\.(mp3|wav|ogg)(\\?.*)?$/i);\nfunction loadAudioFile(ac, name, options) {\n  var url = prefix(options.from, name);\n  return load(ac, load.fetch(url, 'arraybuffer'), options);\n}\n\n// Load the result of a promise\nfunction isPromise(o) {\n  return o && typeof o.then === 'function';\n}\nfunction loadPromise(ac, promise, options) {\n  return promise.then(function (value) {\n    return load(ac, value, options);\n  });\n}\n\n// COMPOUND OBJECTS\n// ================\n\n// Try to load all the items of an array\nvar isArray = Array.isArray;\nfunction loadArrayData(ac, array, options) {\n  return Promise.all(array.map(function (data) {\n    return load(ac, data, options, data);\n  }));\n}\n\n// Try to load all the values of a key/value object\nfunction isObject(o) {\n  return o && typeof o === 'object';\n}\nfunction loadObjectData(ac, obj, options) {\n  var dest = {};\n  var promises = Object.keys(obj).map(function (key) {\n    if (options.only && options.only.indexOf(key) === -1) return null;\n    var value = obj[key];\n    return load(ac, value, options, value).then(function (audio) {\n      dest[key] = audio;\n    });\n  });\n  return Promise.all(promises).then(function () {\n    return dest;\n  });\n}\n\n// Load the content of a JSON file\nvar isJsonFileName = fromRegex(/\\.json(\\?.*)?$/i);\nfunction loadJsonFile(ac, name, options) {\n  var url = prefix(options.from, name);\n  return load(ac, load.fetch(url, 'text').then(JSON.parse), options);\n}\n\n// BASE64 ENCODED FORMATS\n// ======================\n\n// Load strings with Base64 encoded audio\nvar isBase64Audio = fromRegex(/^data:audio/);\nfunction loadBase64Audio(ac, source, options) {\n  var i = source.indexOf(',');\n  return load(ac, base64.decode(source.slice(i + 1)).buffer, options);\n}\n\n// Load .js files with MidiJS soundfont prerendered audio\nvar isJsFileName = fromRegex(/\\.js(\\?.*)?$/i);\nfunction loadMidiJSFile(ac, name, options) {\n  var url = prefix(options.from, name);\n  return load(ac, load.fetch(url, 'text').then(midiJsToJson), options);\n}\n\n// convert a MIDI.js javascript soundfont file to json\nfunction midiJsToJson(data) {\n  var begin = data.indexOf('MIDI.Soundfont.');\n  if (begin < 0) throw Error('Invalid MIDI.js Soundfont format');\n  begin = data.indexOf('=', begin) + 2;\n  var end = data.lastIndexOf(',');\n  return JSON.parse(data.slice(begin, end) + '}');\n}\nif (typeof module === 'object' && module.exports) module.exports = load;\nif (typeof window !== 'undefined') window.loadAudio = load;","map":{"version":3,"names":["base64","require","fetch","fromRegex","r","o","test","prefix","pre","name","load","ac","source","options","defVal","loader","isArrayBuffer","loadArrayBuffer","isAudioFileName","loadAudioFile","isPromise","loadPromise","isArray","loadArrayData","isObject","loadObjectData","isJsonFileName","loadJsonFile","isBase64Audio","loadBase64Audio","isJsFileName","loadMidiJSFile","opts","Promise","resolve","reject","ArrayBuffer","array","done","decodeAudioData","buffer","slice","url","from","then","promise","value","Array","all","map","data","obj","dest","promises","Object","keys","key","only","indexOf","audio","JSON","parse","i","decode","midiJsToJson","begin","Error","end","lastIndexOf","module","exports","window","loadAudio"],"sources":["/Users/macbook/Desktop/Music/OwnGuitar/node_modules/audio-loader/lib/index.js"],"sourcesContent":["'use strict'\n\nvar base64 = require('./base64')\nvar fetch = require('./fetch')\n\n// Given a regex, return a function that test if against a string\nfunction fromRegex (r) {\n  return function (o) { return typeof o === 'string' && r.test(o) }\n}\n// Try to apply a prefix to a name\nfunction prefix (pre, name) {\n  return typeof pre === 'string' ? pre + name\n    : typeof pre === 'function' ? pre(name)\n    : name\n}\n\n/**\n * Load one or more audio files\n *\n *\n * Possible option keys:\n *\n * - __from__ {Function|String}: a function or string to convert from file names to urls.\n * If is a string it will be prefixed to the name:\n * `load(ac, 'snare.mp3', { from: 'http://audio.net/samples/' })`\n * If it's a function it receives the file name and should return the url as string.\n * - __only__ {Array} - when loading objects, if provided, only the given keys\n * will be included in the decoded object:\n * `load(ac, 'piano.json', { only: ['C2', 'D2'] })`\n *\n * @param {AudioContext} ac - the audio context\n * @param {Object} source - the object to be loaded\n * @param {Object} options - (Optional) the load options for that object\n * @param {Object} defaultValue - (Optional) the default value to return as\n * in a promise if not valid loader found\n */\nfunction load (ac, source, options, defVal) {\n  var loader =\n    // Basic audio loading\n      isArrayBuffer(source) ? loadArrayBuffer\n    : isAudioFileName(source) ? loadAudioFile\n    : isPromise(source) ? loadPromise\n    // Compound objects\n    : isArray(source) ? loadArrayData\n    : isObject(source) ? loadObjectData\n    : isJsonFileName(source) ? loadJsonFile\n    // Base64 encoded audio\n    : isBase64Audio(source) ? loadBase64Audio\n    : isJsFileName(source) ? loadMidiJSFile\n    : null\n\n  var opts = options || {}\n  return loader ? loader(ac, source, opts)\n    : defVal ? Promise.resolve(defVal)\n    : Promise.reject('Source not valid (' + source + ')')\n}\nload.fetch = fetch\n\n// BASIC AUDIO LOADING\n// ===================\n\n// Load (decode) an array buffer\nfunction isArrayBuffer (o) { return o instanceof ArrayBuffer }\nfunction loadArrayBuffer (ac, array, options) {\n  return new Promise(function (done, reject) {\n    ac.decodeAudioData(array,\n      function (buffer) { done(buffer) },\n      function () { reject(\"Can't decode audio data (\" + array.slice(0, 30) + '...)') }\n    )\n  })\n}\n\n// Load an audio filename\nvar isAudioFileName = fromRegex(/\\.(mp3|wav|ogg)(\\?.*)?$/i)\nfunction loadAudioFile (ac, name, options) {\n  var url = prefix(options.from, name)\n  return load(ac, load.fetch(url, 'arraybuffer'), options)\n}\n\n// Load the result of a promise\nfunction isPromise (o) { return o && typeof o.then === 'function' }\nfunction loadPromise (ac, promise, options) {\n  return promise.then(function (value) {\n    return load(ac, value, options)\n  })\n}\n\n// COMPOUND OBJECTS\n// ================\n\n// Try to load all the items of an array\nvar isArray = Array.isArray\nfunction loadArrayData (ac, array, options) {\n  return Promise.all(array.map(function (data) {\n    return load(ac, data, options, data)\n  }))\n}\n\n// Try to load all the values of a key/value object\nfunction isObject (o) { return o && typeof o === 'object' }\nfunction loadObjectData (ac, obj, options) {\n  var dest = {}\n  var promises = Object.keys(obj).map(function (key) {\n    if (options.only && options.only.indexOf(key) === -1) return null\n    var value = obj[key]\n    return load(ac, value, options, value).then(function (audio) {\n      dest[key] = audio\n    })\n  })\n  return Promise.all(promises).then(function () { return dest })\n}\n\n// Load the content of a JSON file\nvar isJsonFileName = fromRegex(/\\.json(\\?.*)?$/i)\nfunction loadJsonFile (ac, name, options) {\n  var url = prefix(options.from, name)\n  return load(ac, load.fetch(url, 'text').then(JSON.parse), options)\n}\n\n// BASE64 ENCODED FORMATS\n// ======================\n\n// Load strings with Base64 encoded audio\nvar isBase64Audio = fromRegex(/^data:audio/)\nfunction loadBase64Audio (ac, source, options) {\n  var i = source.indexOf(',')\n  return load(ac, base64.decode(source.slice(i + 1)).buffer, options)\n}\n\n// Load .js files with MidiJS soundfont prerendered audio\nvar isJsFileName = fromRegex(/\\.js(\\?.*)?$/i)\nfunction loadMidiJSFile (ac, name, options) {\n  var url = prefix(options.from, name)\n  return load(ac, load.fetch(url, 'text').then(midiJsToJson), options)\n}\n\n// convert a MIDI.js javascript soundfont file to json\nfunction midiJsToJson (data) {\n  var begin = data.indexOf('MIDI.Soundfont.')\n  if (begin < 0) throw Error('Invalid MIDI.js Soundfont format')\n  begin = data.indexOf('=', begin) + 2\n  var end = data.lastIndexOf(',')\n  return JSON.parse(data.slice(begin, end) + '}')\n}\n\nif (typeof module === 'object' && module.exports) module.exports = load\nif (typeof window !== 'undefined') window.loadAudio = load\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}