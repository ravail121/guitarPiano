{"ast":null,"code":"import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n    this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n    this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n    this._tickOffset = new Timeline();\n    const options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    this.frequency = new TickSignal({\n      context: this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(this, \"frequency\");\n    // set the initial state\n    this._state.setStateAtTime(\"stopped\", 0);\n    // add the first event\n    this.setTicksAtTime(0, 0);\n  }\n  static getDefaults() {\n    return Object.assign({\n      frequency: 1,\n      units: \"hertz\"\n    }, ToneWithContext.getDefaults());\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n  get state() {\n    return this.getStateAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset The number of ticks to start the source at\n   */\n  start(time, offset) {\n    const computedTime = this.toSeconds(time);\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n      if (isDefined(offset)) {\n        this.setTicksAtTime(offset, computedTime);\n      }\n    }\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   */\n  stop(time) {\n    const computedTime = this.toSeconds(time);\n    // cancel the previous stop\n    if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n      const event = this._state.get(computedTime);\n      if (event && event.time > 0) {\n        this._tickOffset.cancel(event.time);\n        this._state.cancel(event.time);\n      }\n    }\n    this._state.cancel(computedTime);\n    this._state.setStateAtTime(\"stopped\", computedTime);\n    this.setTicksAtTime(0, computedTime);\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n    }\n    return this;\n  }\n  /**\n   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n   * @param time When to clear the events after\n   */\n  cancel(time) {\n    time = this.toSeconds(time);\n    this._state.cancel(time);\n    this._tickOffset.cancel(time);\n    return this;\n  }\n  /**\n   * Get the elapsed ticks at the given time\n   * @param  time  When to get the tick value\n   * @return The number of ticks\n   */\n  getTicksAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    const stopEvent = this._state.getLastState(\"stopped\", computedTime);\n    // this event allows forEachBetween to iterate until the current time\n    const tmpEvent = {\n      state: \"paused\",\n      time: computedTime\n    };\n    this._state.add(tmpEvent);\n    // keep track of the previous offset event\n    let lastState = stopEvent;\n    let elapsedTicks = 0;\n    // iterate through all the events since the last stop\n    this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n      let periodStartTime = lastState.time;\n      // if there is an offset event in this period use that\n      const offsetEvent = this._tickOffset.get(e.time);\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedTicks = offsetEvent.ticks;\n        periodStartTime = offsetEvent.time;\n      }\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n      }\n      lastState = e;\n    });\n    // remove the temporary event\n    this._state.remove(tmpEvent);\n    // return the ticks\n    return elapsedTicks;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked. Returns -1 when stopped.\n   */\n  get ticks() {\n    return this.getTicksAtTime(this.now());\n  }\n  set ticks(t) {\n    this.setTicksAtTime(t, this.now());\n  }\n  /**\n   * The time since ticks=0 that the TickSource has been running. Accounts\n   * for tempo curves\n   */\n  get seconds() {\n    return this.getSecondsAtTime(this.now());\n  }\n  set seconds(s) {\n    const now = this.now();\n    const ticks = this.frequency.timeToTicks(s, now);\n    this.setTicksAtTime(ticks, now);\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n  getSecondsAtTime(time) {\n    time = this.toSeconds(time);\n    const stopEvent = this._state.getLastState(\"stopped\", time);\n    // this event allows forEachBetween to iterate until the current time\n    const tmpEvent = {\n      state: \"paused\",\n      time\n    };\n    this._state.add(tmpEvent);\n    // keep track of the previous offset event\n    let lastState = stopEvent;\n    let elapsedSeconds = 0;\n    // iterate through all the events since the last stop\n    this._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n      let periodStartTime = lastState.time;\n      // if there is an offset event in this period use that\n      const offsetEvent = this._tickOffset.get(e.time);\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedSeconds = offsetEvent.seconds;\n        periodStartTime = offsetEvent.time;\n      }\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedSeconds += e.time - periodStartTime;\n      }\n      lastState = e;\n    });\n    // remove the temporary event\n    this._state.remove(tmpEvent);\n    // return the ticks\n    return elapsedSeconds;\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n  setTicksAtTime(ticks, time) {\n    time = this.toSeconds(time);\n    this._tickOffset.cancel(time);\n    this._tickOffset.add({\n      seconds: this.frequency.getDurationOfTicks(ticks, time),\n      ticks,\n      time\n    });\n    return this;\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   */\n  getStateAtTime(time) {\n    time = this.toSeconds(time);\n    return this._state.getValueAtTime(time);\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n  getTimeOfTick(tick) {\n    let before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.now();\n    const offset = this._tickOffset.get(before);\n    const event = this._state.get(before);\n    const startTime = Math.max(offset.time, event.time);\n    const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n    return this.frequency.getTimeOfTick(absoluteTicks);\n  }\n  /**\n   * Invoke the callback event at all scheduled ticks between the\n   * start time and the end time\n   * @param  startTime  The beginning of the search range\n   * @param  endTime    The end of the search range\n   * @param  callback   The callback to invoke with each tick\n   */\n  forEachTickBetween(startTime, endTime, callback) {\n    // only iterate through the sections where it is \"started\"\n    let lastStateEvent = this._state.get(startTime);\n    this._state.forEachBetween(startTime, endTime, event => {\n      if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n        this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n      }\n      lastStateEvent = event;\n    });\n    let error = null;\n    if (lastStateEvent && lastStateEvent.state === \"started\") {\n      const maxStartTime = Math.max(lastStateEvent.time, startTime);\n      // figure out the difference between the frequency ticks and the\n      const startTicks = this.frequency.getTicksAtTime(maxStartTime);\n      const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n      const diff = startTicks - ticksAtStart;\n      let offset = Math.ceil(diff) - diff;\n      // guard against floating point issues\n      offset = EQ(offset, 1) ? 0 : offset;\n      let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n      while (nextTickTime < endTime) {\n        try {\n          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n        } catch (e) {\n          error = e;\n          break;\n        }\n        nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n      }\n    }\n    if (error) {\n      throw error;\n    }\n    return this;\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    this._state.dispose();\n    this._tickOffset.dispose();\n    this.frequency.dispose();\n    return this;\n  }\n}","map":{"version":3,"mappings":"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","names":["ToneWithContext","optionsFromArguments","readOnly","StateTimeline","Timeline","isDefined","TickSignal","EQ","TickSource","constructor","getDefaults","arguments","options","frequency","context","units","value","_state","setStateAtTime","setTicksAtTime","Object","assign","state","getStateAtTime","now","start","time","offset","computedTime","toSeconds","getValueAtTime","stop","event","get","_tickOffset","cancel","pause","getTicksAtTime","stopEvent","getLastState","tmpEvent","add","lastState","elapsedTicks","forEachBetween","sampleTime","e","periodStartTime","offsetEvent","ticks","remove","t","seconds","getSecondsAtTime","s","timeToTicks","elapsedSeconds","getDurationOfTicks","getTimeOfTick","tick","before","startTime","Math","max","absoluteTicks","forEachTickBetween","endTime","callback","lastStateEvent","error","maxStartTime","startTicks","ticksAtStart","diff","ceil","nextTickTime","round","dispose"],"sources":["/Users/macbook/Desktop/Music/OwnGuitar/node_modules/tone/Tone/core/clock/TickSource.ts"],"sourcesContent":["import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tunits: \"bpm\" | \"hertz\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource<TypeName extends \"bpm\" | \"hertz\"> extends ToneWithContext<TickSourceOptions> {\n\n\treadonly name: string = \"TickSource\";\n\n\t/**\n\t * The frequency the callback function should be invoked.\n\t */\n\treadonly frequency: TickSignal<TypeName>;\n\n\t/**\n\t * The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\t/**\n\t * @param frequency The initial frequency that the signal ticks at\n\t */\n\tconstructor(frequency?: number);\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units as TypeName,\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\" as \"hertz\",\n\t\t}, ToneWithContext.getDefaults());\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t * @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t * The time since ticks=0 that the TickSource has been running. Accounts\n\t * for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds: this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t * Invoke the callback event at all scheduled ticks between the\n\t * start time and the end time\n\t * @param  startTime  The beginning of the search range\n\t * @param  endTime    The end of the search range\n\t * @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: number, endTime: number, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(startTime);\n\t\tthis._state.forEachBetween(startTime, endTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error: Error | null = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\") {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, startTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = Math.ceil(diff) - diff;\n\t\t\t// guard against floating point issues\n\t\t\toffset = EQ(offset, 1) ? 0 : offset;\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < endTime) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}